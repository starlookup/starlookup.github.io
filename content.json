{"posts":[{"title":"IETLS 学习","text":"Just for myself! 只有 14% 的学生可以拿到 7 分以上 口语和写作重点强化 听力和阅读最少 8 分 雅思考试内容 听力 阅读 写作 口语 听力 Step one: 第一天，按照雅思考试的流程进行练习，听完整个一个test 的内容。之后，对照答案，只标出对错，但是不改正答案。 Step two: 第二天，分析整个test 里的错题。把错误的题重新听一下做一遍。 Step three: 直接能改正好的题，跳过。不能改正好的题，听写题目所在的内容。 Step four: 听写的时候，一句一停顿，听完一遍之后重复播放，直到自己认为写全了原文内容为止。之后，和听力原文对照，重点看写的不对的地方，同时分析错误的原因。 Step five：改完所有的错题，翻到听力原文的部分，把自己认为听的不好的section 看着听力原文通听一遍。一边听，一边标记出自己认为听得不太清楚的表达。 每日6分钟 加上一套练习 阅读 精读配合泛读 两天一套 test 每两天一套test: 第一天按时1 hour 完成，第二天分析题目 0-12 mins: 完成part 1，并填好相应答题卡 12-30 mins: 完成part 2, 并填好相应答题卡 30-55 mins: 完成 part 3, 并填好相应答题卡 55-60 mins: 检查自己的答案，查缺补漏 每日练习真题，按照上面的来 写作 小作文 每种看几篇范文，记下表达方式与框架 大作文 练就完事了 前期先看，跟着那本书走 口语 top sentence+ explain + example + conclusion/results 自己的理解 (7.0 分标准)： Fluency and Coherence: 1. 减少停顿和中途思考的时间 2. 尽量减少自我更正的次数 3. 回答中使用连接词过渡 4. 多表达，展示自己用英语交流的兴趣 5. 详细展开答案 Lexical Resource: 1. 描述同一事物时用不同的表达方法 2. 多用副词，形容词等修饰性词 3. 多用词伙（collocations） Grammatical Range and Accuracy: 1. 用不同的句式，复杂句和简单句交替使用 2. 减少语法错误 Pronunciation: 1. 不要纠结口音 2. 发音清晰 前期跟着那本书走，后期开练 10月19号（天气晴，心情良）List 1 physician n.内科医生 resort n.求助 excavate vt.挖掘 mutual a.相互的 impart vt.给予 forfeit v.（因犯规等而）丧失，失去 n.罚款 intermediate a.中间的 10月20号（天气🌞，心情良）List 2 regional a.局部范围的 preserve vt.保护；维持；保存；保藏 item n.条款 fabrication n.捏造 tram n.有轨电车 V.乘电车 maturity n.成熟 evacuate v.疏离 surge v.蜂拥而出 n.洋溢 10月23号（天气🌞，心情良）List 3 impede vt.阻碍 deduce v.演绎 doctorate n.博士学位 internship n.实习生身份 notion n.概念 lavatory n.厕所 irritation n.激怒 induce vt.引诱；引起 slit n.淤泥 10 月 24 日（天气晴，心情ok） reservation n.保留意见；预定 reasonable a.合理的 abode n.房屋 gadget n.小巧的器械；小玩意 strike v.打；折磨；罢工 dispute n.争论v.争论 exclusively ad.专门的 feather n.羽毛 10 月 26 日（天气晴，心情ok） vertebrate n.脊椎动物 industrious a.勤奋的 intestine n.肠 outpost n.前哨 consignment n.委托；投递 convention n.大会 humble a.谦逊的 divisional a.部门的 regulate v.管制；调节 10 月 27 日（天气阴，心情一般） discretion n.判断力 substitute v.代替 n.代替者 striking a.显著的 pirate n.侵犯版权者，海盗 vt.盗用 decrepit a.破旧的 ignorant a .无知的 leopard n.豹，美洲豹 mastery n.精通 recruit v.招募；复原；补充 n.新兵 gloss n.光泽 representation n.代理人 a.典型的 thrive vi.兴旺 consequently ad.因而 withstand vt.抵挡 anthoropologist n.人类学家 suitably ad.合适的 10 月 28 日（天气雨，心情一般） pulley n.滑轮 privilege n.特权 vt.给予特权 qualification n.资格；技能；条件；合格证 expand v.膨胀；详述 intern vt.拘禁，软禁 specialist n.专家 migratory a.迁徙的 inlet n.入口；水湾 hazard n.危险，冒险 v.冒…风险 alight a.点着的 vi.降落 shrewd a.机灵的 explosive n.爆炸物 a.爆炸的 inherent a.内在的 lever vt.撬动 n.杠杆 latent a.潜在的 11 月 2 日（天气晴，心情一般） ​ tenant n. 承租人 psychiatric a.精神病的 bolster vt.支持；改善；n.垫子 exotic a.外来的；奇异的；醒目的；吸引人的 evaporate a.蒸发；消失 virtually ad.几乎；实际上 tangibly ad.可触摸的 windscreen n.挡风玻璃 alluvial a.冲击的，淤积的 fossil n.化石 execution n.执行 11 月 4 日（天气晴，心情一般） heritage n.遗产 depict vt.描述 dormancy n.休眠 cope vi.（成功的）应付；处理 decay n.分发；配给物 v.腐烂 defect n.缺点；vi.叛变 excusable a.可原谅的 11 月 5 日（天气阴，心情一般） atmospheric a.大气的 corrode v.腐蚀 antidote n.解毒药 turret n.塔楼 elastic a.有弹性的；灵活的 n.松紧带 redundant a.多余的 suppression n.镇压 naked a.裸体的 nourish vt.养育 11 月 9 日（天气阴，心情一般） flourish v.繁茂；茂盛；n.夸张动作 gravel n.沙砾 insulation n.隔绝；绝缘 undermine vt.削弱 eliminate vt.消灭 apparently ad.显然 gelatin n.明胶 stimulate vt.刺激；激发 fuel n.燃料 probation n.缓刑；试用期 devastate vt.破坏 tropical a.热带的 endeavour n/vi 努力；尝试 11 月 10 日（天气晴，心情一般） illuminate vt.照亮 warrant v.保证 n.授权 verdict n.裁定 refresher n.提神物 administrative a.管理的 deputy n.代理人 fragrance n.芳香；香水 unyielding a.顽强的 11 月 11 日（天气晴，心情一般） formulate vt.系统阐述；构想出 creep vi.悄悄移动；爬行 casual a.偶然的 interpretation n.口译 furnish vt.布置；供应 stabilise v.稳定 narrator n.讲述者 reckon v.认为 11 月 13 日（天气晴，心情一般） exaggerate v.夸大 magnetic a.磁的；有吸引力的 graphic a.文字的；生动的；绘画的 stimulus n.刺激 roam v.随便走；徜徉 n.漫步 provided conj. 倘若；只要 publicity n.宣传 composition n.作品；组成 damp a.潮湿的 n.潮湿 homogeneous a.同种类的 terrace n.阳台 11 月 16 日（天气晴，心情一般） fumes n.烟，气 liberty n.自由 poll n.民意测验 refundable a.可退换的 glide vi/n 滑行 mattress n.床垫 digestive a.消化的 practically ad.几乎 foremost a.最好的 11 月 17 日（天气晴，心情一般） ​ plagiarism n.剽窃，抄袭 pledge v.正式承诺；发誓 n.誓约 vessel n.船只 stereo a.立体声的 11 月 21 日（天气晴，心情一般） aesthetic a.美学的 recreation n.娱乐 perceive vt.感知 proportion n.比例；部分 offset vt.抵消 intact a.完整无缺的 siesta n.午睡 detour n.弯路 11 月 23 日（天气晴，心情一般） cosmic a.宇宙的 supervisor n.监督人 permanent a.永久的 embed vt.使深留脑中 deprive vt.剥夺 amaze vt.使惊奇 asset n.财产 sophisticated a.老于世故的；精密的 intimate a.亲密的 n.至交 vt.暗示 calibre n.质量；口径 harsh a.严厉的 parliament n.议会 11 月 24 日（天气晴，心情一般） dweller n.居住者 coverage n.新闻报道；覆盖范围 specialty n.特产 intrinsic a.固有的；本质的 turnover n.营业额；人事变动率 lateral a.侧面的 export v.出口 n.出口 marvellous ad.令人惊奇的；奇特的；奇迹般的 tribute n.贡品；称赞 11 月 25 日（天气晴，心情一般） primitive a.原始的；简单的 n.原始人 barge n.驳船v.猛闯 aerobics n.有氧 exacerbate vt.恶化 crater n.火山口 11 月 26 日（天气晴，心情一般） flexibility n.柔韧；柔顺；灵活性 controversy n.争论 sensation n.感觉能力 recipient n.接受者 identical a.完全相同的 tropospheric a.对流层的 predominantly ad.主要地 11 月 27 日（天气晴，心情一般） mineral n.矿物 moderation n.温和；适度 vocational a.职业的 coffer n.保险箱 turbine n.涡轮机 compatible a.兼容的 proposal n.提议 audacious a.大胆的 tramp v.跋涉 pest n.害虫 12月1日（天气雨，心情一般） amount n.总额 vi.合计 manipulate vt.应付；操纵；影响 juvenile a.少年的 vulnerable a.易受攻击的 steam n.气雾 v.发出蒸汽；行驶 valuable a.贵重的，有价值的 n.贵重物品 sanctuary n.圣堂；庇护所 12月2日（天气雨，心情🉑️） deception n.欺骗；诡计 terrain n.地形 overwhelm vt.征服 bump into 不期而遇 miserable a.悲惨的 pliable a.容易受人影响的 disposal n.处理；布置 subsidiary n.子公司 feeble a.虚弱的 nominal a.名义上的 12月3日（天气❄️，心情🉑️） gross a.总的 refusal n.拒绝 coupon n.优惠券 expectancy n.期待 genuine a.真正的 12月3日（天气阴，心情🉑️） slope n.斜坡 prey n.猎物；牺牲品 screw v.用螺丝固定 n.螺丝 delicate a.纤细的 venture v.敢于去 n.风险投资 shrink v.收缩 12月6日（天气☀️，心情🉑️） flip v.轻弹 provision n.供应 internist n.内科医生 prospective a.预期的；未来的；可能的 stammer n.结巴 fickle a.易变的 12月8日（天气☀️，心情🉑️） prevail vi.流行，盛行；占优势 mansion n.大厦 deficiency n.缺乏 sensational a.轰动性的；耸人听闻的；极好的 pretension n.声称；自负 detach v.分开 torrent n.洪流 inspect vt.检阅 12月11日（天气☀️，心情🉑️） sediment n.沉淀物；沉积物 resit v/n.重修 menace n.威胁；危险的人 vt.威胁到 contain vt.包含；控制，阻止 fasten v.扎牢 scratch n.划伤，抓痕 v.抓；划破 mammal n.哺乳动物 serial n.连续剧 a.连续的 jungle n.丛林 optical a.视力的 retail n.零售 v.零售 transcation n.办理；处理；交易 [pl.]会报 12月14日（天气☀️，心情🉑️） germ n.微生物；起源 spade n.铁锹 parcel n.包裹 vice verse 反而亦然 foetus n.胎儿 stationery n.文具 12月16日（天气☀️，心情🉑️） impulse n.冲动；刺激；脉冲 imcapacitate vt.使无能为力；使伤残 conceive v.想出，构想；怀孕 course n.过程；路线；跑道 v.追猎 degrade v.降级；堕落；降解；退化 partical n.极少量 gorge v.狼吞虎咽，塞饱 n.峡谷 recreational a.消遣的；游戏的 12月21日（天气☀️，心情🉑️） seal vt.封，密封 n.封铅；图章；海豹 scarce a.缺乏的；罕见的 exclusive a.奢华的；独有的；排他的 n.独家新闻 vertical a.垂直的 n.垂直线 flat a.平的；固定的 fracture n.断裂；骨折 v.断裂 12月29日（天气☀️，心情🉑️） glacial a.冰期的；寒冷的 teem vi.倾泻 exhibition n.展览 whereas conj.然而 poultry n.家禽 postgraduate n.研究生 premuim a.高级的 n.保险费 1月7日（天气☀️，心情🉑️） discerning a.有识别力的 chill n.寒意 a.寒冷的 exposure n.暴露；接触 premium a.高级的 deceive v.欺骗 facility n.设备 statue n.塑像 1月8日（天气☀️，心情🉑️） simultaneous a.同时的 sundial n.日晷 dormant a.休眠的 engrave vt.雕刻 territory n.领土 1月11日（天气☀️，心情🉑️） hallowed a.受尊敬的 bring around /round 说服；使恢复知觉 relevance n.中肯；相关性 reluctant a.不情愿的 laterality n.对一侧面的偏重 integral a.不可或缺的 sporadically ad.偶发的 expedition n.远征；旅行；远征队 1月12日（天气☀️，心情🉑️） postpone v.延迟，延期 aggravation n.加重 lull n.间歇 plush a.豪华的 dispense vt.分发 charter n.纲领；宪章 1月14日（天气☀️，心情🉑️） thigh n.大腿 entrust vt.委托 pamper vt.纵容；精心护理 veterinarian n.兽医 derelict a.被抛弃的 n.遗弃物 synchronise v.同步发生 ornamental a.装饰性的 irritate vt.使烦躁；刺激 initiative n.倡议；主动性；主动权 rotate v.（使）旋转，转动；轮流 1月15日（天气☀️，心情🉑️） destination n.目的地 in accordance with 按照 envisage vt.展望 binoculars n.双筒望远镜 glutamate n.谷氨酸 erroneous a.错误的 robust a.健壮的 indigenous a.土产的 sympathetic a.同情的 1月18日（天气☀️，心情🉑️） gleam vi.闪烁 sole a.唯一的 rudimentary a.基本的；未充分发展的 ritual n.典礼 interpret v.解释 preliminary a.开端的 turbid a.混沌的","link":"/2020/10/01/IELTS/"},{"title":"Makefile 使用","text":"简单易忘的知识记录 Makefile 基础的 Makefile 规则 target … : prerequisites … command … … target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。 prerequisites就是，要生成那个target所需要的文件或是目标。 command也就是make需要执行的命令。（任意的Shell命令） 在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。 在我们的makefile中以“$(objects)”的方式来使用这个变量 .PHONY : clean clean : -rm edit $(objects) 前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。！ Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 1、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 2、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。 3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。 4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 5、注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“/#”。 最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。 Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。目录由 ：号分割。","link":"/2020/07/07/base_knowledge/"},{"title":"每日阅读","text":"还是擦肩天桥上，无意间的回眸 每日阅读9 月 17 日（天气晴）[技术分享】Android代码混淆技术总结（一）(https://www.anquanke.com/post/id/85843) 控制流平坦化：在不改变源代码的功能前提下，将 C 或 C++ 代码中控制语句转换成 switch 分支语句，使更加复杂 目前使用的比较多的 OLLVM 的开源混淆方案，其中包括控制流平坦化、虚假控制流和指令替换 花指令：花指令是位于永远不能执行的路径中，且是不完整指令而已。运行过程中，因为执行不到所以不会影响整体功能，但是若是反汇编工具的话，因为是静态反汇编就会失败。 标识符混淆：对源程序的包名、类名、方法名和变量名进行重命名，用无意义的标识符来替代。 常用的 ProGuard 工具 字符串混淆；对于源程序的比较关键的字符串变量进行混淆，一种是 Java 层的字符串，另一种是native层 编码混淆、加密处理 红队安全研发系列之免杀原理和绕过研究——起始(https://www.anquanke.com/post/id/217529) 静态查杀分为已知类型查杀与未知类型查杀 已知类型查杀——特征码查杀，按照指定模式进行特征匹配的算法，而具体使用什么类型的规则（既各种扫描算法）取决于扫描器，例如YARA规则。YARA是一款旨在帮助恶意软件研究人员识别和分类恶意软件样本的开源工具 未知类型查杀——静态启发式查杀，启发式查杀是对单一特征码查杀的补充，解决未知病毒查杀。早期杀软都是发现病毒，制作该病毒的特征码，但是对于未知病毒就无法查杀，而启发式则是将一类病毒总结后，归纳其特征，其后的演变都为一类病毒，这既是启发式算法。 动态查杀分为指定类型查杀与聚类类型查杀。某杀软查杀cobaltstrike等知名远控则是通过shell code内存匹配来进行查杀。 9 月 18 日（天气☀️，心情😄）JSON Web Token（JWT）攻击技巧 JWT 是一个轻量级业务流程管理规范，允许用户和服务器之间可靠传递消息。通常实现前端和后端的解藕，同时，它还可以与Restful API 一起使用，用于身份验证。 JWT 数据分为三部分：头部，有效载荷，签名。通过base64UrlEncode函数将三者隔开来 主要攻击技术 敏感信息泄漏，有效载荷时明文形式传输，因此，有效载荷中存在敏感信息，就会泄漏 将签名算法改为 none。系统就会删除相应的签名数据 将 RS256 算法改为 HS256（非对称密码算法-&gt;对称密码算法） 破解HS256密钥 蜜罐调研与内网安全(https://xz.aliyun.com/t/7294) 蜜罐系统通过在网络中部署感应节点，实时感知周边网络环境，同时将感应节点日志实时存储、可视化分析，实现威胁情况感知。 一个好的蜜罐：能模拟大多数常见协议、能够模拟影响面广泛的应用协议和漏洞、能够在TCP/UDP端口捕获未知的恶意扫描、蜜罐便于协议扩展、蜜罐结果的数据格式简单便于分析 web蜜罐、服务蜜罐、其他蜜罐 logstash 日志解析，elasticsearch 日志存储、分析，kibana 可视化 自监督图神经网络(https://www.anquanke.com/post/id/217522) 实际中大多数数据并不是如图像与自然语言一样的数据具有高度结构化与顺序化的。人际关系、社交网络、蛋白质分子结构等等，这些数据往往都具有一对多、多对一、非结构化等特性，无法使用矩阵完美表示，然而这些数据可以用图的形式进行精确表达。 将深度学习的技术与思想应用于图数据结构之上催生了图神经网络。图神经网络可以捕获节点之间依赖关系，根据节点自身以及其周围邻域节点的信息建立状态的内部表示，以此获得比神经网络更为强大的表示能力。 GRAPH-BERT 从对老漏洞的分析谈二进制漏洞入门(https://www.freebuf.com/vuls/248394.html) 所需要具备的知识，一方面逆向分析（汇编语言、动态调试、静态分析）、代码审计。另一方面，多思考，多分享 漏洞背景：tcpdump4.5.1版本爆出拒绝服务漏洞。漏洞产生的原因是在函数hex_and_anscii_print_with_offset()没有对无符号型变量caplength进行检查，导致在运算过程中，整数溢出，内存访问越界。 通过不停的函数回溯进行分析，找到程序崩溃的原因以及地址所代表的意义，对于简单的漏洞，分析的综合能力不用那么强，padding 不是一定的。介绍了完整的漏洞分析场景，值得一读。 leetcode-twosun Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1]. 很简单的题目，主要题解分为循环以及 hashmap 两种思想都可。 ```def twoSum(nums, target):hashmap = {}for i, num in enumerate(nums): if hashmap.get(target - num) is not None: return [i, hashmap.get(target - num)] hashmap[num] = iif name == “main“:nums = [2,7,9,11]target = 9print(twoSum(nums, target)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384##### 9月19日 （天气☀️，心情累💢）- 一双vans、一顿饭、AirPods，心情瞬间变好了。果然花钱是让心情变好的最简单方式～###### 发现内网存活主机的各种姿势（一）- namp 命令行 - -sU 基于 UDP 的扫描 - -T5 namp的扫描速度 -T(0-5) 越大越快 - -sV 探测开启的端口来获取服务、版本信息 - -sn 不扫描端口，只扫描主机 -PR ARP ping扫描 -sP Ping扫描 sn -P0 无Ping扫描 -PS TCP SYN Ping扫描 -PA TCP ACK Ping扫描 -PU UDP ping扫描 -PE/PM/PP ICMP Ping Types扫描9月20日 （天气🌧️，心情愉悦✨）###### CTF特训营（211-269）- chrome 中的 F12 中 sources 通常用于下断点调试，Application 记录网站加载的所有资源信息，包括存储数据（Local Storage、Session Storage、cookie）、缓存数据、字体、图片，security从技术层面判断当前网页是否安全，不能判断内容上的，只能判断是否代码可疑、证书是否合法- SQL 注入成因，在开发过程中，将 URL 中的参数、HTTP Body 中的 Post 参数或其他外来用户输入与 SQL 语句进行拼接，造成语句可控从而达到任意执行。- 可回显得注入（联合查询的注入、报错注入、通过注入的DNS请求，从而达到可回显）、不可回显注入（Bool盲注、时间盲注）、二次注入- 有两种广泛使用 的x64 ABI - Microsoft‘s x64 ABI:前4个参数通过寄存器 RCX、RDX、R8、R9传递，其余则是通过栈传递，但在栈上会预留 0x20 字节的空间用于临时保存前 4 个参数，返回值 RAX - RAX func(RCX, RDX, R8, R9, [rsp+0x20], [rsp+0x28], ...... ) - SysV x64 ABI:前 6 个参数（RDI、RSI、 RDX、RCX、R8、R9、[RSP+8]、[RSP+0x10], ......）- IDA 使用 FLIRT 签名库的方式来识别函数，因此即使没有带符号信息的二进制程序，也可能识别库函数。对于不能识别的函数函数名会以sub_开头，后面再加入函数的起始地址。- 常见算法逆向 - base64 ：如果有见到索引表 ‘ABCDEFGHIJKLMN等等’基本就是确定了 base64 - TEA：对 TEA 的识别也比较容易，在 TEA 算法中有一个固定的常数 0x9e3779b9 或者 0x61c88647 - AES：主要是寻找 S 盒和逆 S 盒 - RC4: 主要是寻找初始化代码 - MD5: 会初始化四个称作 MD5 的链接变量的整数参数，因此看见0x67452301、0xefcdab89、0x98badcfe、0x10325476###### [2. Add Two Numbers](https://leetcode-cn.com/problems/add-two-numbers/)&gt; You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&gt;&gt; You may assume the two numbers do not contain any leading zero, except the number 0 itself.&gt;&gt; Example:&gt;&gt; Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807.- 基础数据结构题，没有什么大的难度，主要是细节考虑到位就行- ``` def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: • result = p = ListNode(None) • flag = 0 • while l1 or l2 or flag: • flag = flag + (l1.val if l1 else 0) + (l2.val if l2 else 0) • p.next = ListNode(flag%10) • p = p.next • flag = flag // 10 • l1 = l1.next if l1 else None • l2 = l2.next if l2 else None • return result.next 红队安全研发系列之免杀原理和绕过研究——静态查杀实现与绕过（https://www.anquanke.com/post/id/217531） 特征码和启发式查杀在免杀制作过程中，需要注意启发式查杀对壳一类的查杀非常厉害。 特征码查杀绕过可以通过对文件反复加密，加密方式可以自选，之后内存解密加载即可。 注意：这里仅仅是绕过静态特征码查杀，内存加载后被动态查杀。对于 Xor 和 base64 等加密后特征一致的算法需要多次加密。 启发式查杀，主要通过模仿正常 PE 特征。 Glibc 内存管理 .bss 段与堆栈之间的空间是空闲的，空闲空间被分成两个部分，一部分是 heap，一部分是 mmap 映射区域。Heap 和 mmap 区域都可以供用户自由使用，在向内核请求分配空间之前，对这个空间的访问会导致 segmentation fault。 内存管理风格 C 风格的内存管理程序主要实现 malloc() 和 free() 函数，内存管理程序主要通过调用 brk() 或者 mmap() 添加额外虚拟内存。 池式内存管理，内存池是一种半内存管理方法。内存池帮助某些程序进行自动内存管理，这些程序会经历一些特定的阶段，而且每个阶段中都有分配给进程的特定阶段的内存。例如apache 引用计数，所有共享的数据结构都有一个域来包含当前活动“引用”结构的次数。例如 Java 垃圾收集，全自动检测并移除不再使用的对象，通常会在可用内存少于一个具体的阈值时候运行。为了有效地管理内存，很多类型的垃圾收集器都需要知道数据结构内部指针的规划，所以，为了正确运行垃圾收集器，它们必须是语言本身的一部分。 12-13 讨论各种 C 内存管理程序，可以多看看 在 SMP 多线程环境下，对主分配区锁争用激烈，于是增加了非主分配区（non main arena），主分配区域与非主分配区用环形链表管理。每一个分配区有互斥锁。 malloced chunk A 表示是否是主分配区还是非主分配区，M表示是从 mmap 区域还是 heap 区域分配的，P 表示前面一个 chunk 是否在使用。p 为 0 时 prev_size 才有用 free chunk Bins 。用户free掉的内存并不马上归还给系统，ptmalloc 会统一管理 heap 和 mmap映射区域的空闲的 chunk，ptmalloc 将相似大小的 chunk 用双向链表连接起来，一个链表被称为一个 bin。1 个 unsorted bin，2-64 small bins，同一 small bin 中的 chunk 具有相同的大小，两个相邻的 small bins 相差 8 bytes。 9月21号（天气☔️，心情良） CTF特训营(268-) IDAPython、Angr 花指令 Linux常见反调试方法 利用 ptrace，Linux 下的调试主要是通过 ptrace 系统调用实现，一个进程只能被一个程序跟踪，所以如果程序被跟踪之后再来调用 ptrace 自然不会成功 proc 文件系统检测，读取 /proc/self 目录下的部分文件，根据程序在调试和非调试状态下的区别来进行反调试。 通过 getppid 系统调用获取得到程序的父进程，如果父进程是 gdb、strace 或者 ltrace ，则可以证明程序正在被调试。 针对以上的方法反调试方法。常用的方法就是定位到反调试的代码，然后 patch 加壳，加壳的程序真正的代码是加密存放在二进制文件中的，只有在执行时才从内存中解密还原出来，因此没法对加壳后的程序直接进行静态分析。 控制流混淆，对于控制流混淆的程序通常采用 trace 的方法。通过 Trace 工具记录下程序运行的所有指令，然后在运行这些指令的基础上进行数据流分析。 双进程保护，Debug Blocker。是一种在调试模式下运行自身程序的方法。这种保护通常存在两个进程，两个进程是调试器与被调试器的关系。由于真正的功能通常位于子进程中，所以要调试子进程，就必须先断开与已有调试器的链接。 虚拟机保护，将代码翻译为机器和人都无法识别的一串伪代码字节流，在具体执行时再对这些伪代码进行逐一翻译、解释。用于翻译伪代码并具体执行的子程序称为虚拟机。对于一个虚拟机而言它定义了一套自己的指令集架构（ISA），包括寄存器集、内存和指令集。 C# Java 等解释型语言编译后会变成字节码，幸运的是，大多数字节码与源码存在对应关系，保留了很多信息，例如函数名、变量名。 3. Longest Substring Without Repeating Characters难度中等 Given a string s, find the length of the longest substring without repeating characters. Example 1: 123Input: s = &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: s = &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: s = &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3.Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 123456789101112131415class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: ans = '' tep = '' for i in s: if i not in tep: tep += i else: tep = tep[tep.index(i) + 1:] tep += i if len(tep) &gt; len(ans): ans = tep return len(ans) 红蓝对抗中的近源渗透 蓝军是攻击方，红军是防守方 近源渗透定义为“指测试人员靠近或位于测试目标建筑内部，利用各类无线通信技术、物理接口和智能设备进行渗透测试的方法总称”。 正确的上网方式：软路由入门指南 “软路由”是特指将x86 PC或服务器通过特定软件实现路由功能。但本文的内容广泛一点。为了便于表达，我们暂且把所有可以运行自定义系统的路由器称为软路由吧。可以自行安装OpenWRT、DD-WRT的设备，我们都称为软路由。 提起这个，您的第一反应可能是TP-Link、腾达、水星等品牌的家用路由器。它们有一个特点：路由器的系统是由厂商基于Vxworks等系统，自行开发的嵌入式系统。一般来说，只能使用原厂的系统，而且功能不多。腾达的路由，要刷个水星的系统，是不可能的。 有这么一类操作系统，由社区开发维护，支持多种硬件平台。这些系统上的应用程序也可以算跨平台使用，而且应用程序非常丰富。著名的软路由系统有OpenWRT、潘多拉、梅林（午餐肉）、DD-WRT、Tomato，还有国内较为著名的iKuai等。 刷机的方法，一言蔽之就是通过漏洞获得路由器 Root shell，然后解锁 Bootloader 区并且刷入。 9 月 28 日（天气阴，心情好）从0开始聊聊自动化静态代码审计工具 自动化代码审计重点在于漏报率与误报率 动态代码审计工具（IAST），最常见的方法 Hook 恶意函数或是 api 并通过前端爬虫判别是否触发恶意函数来确实漏洞。 IAST 优点在于误报率比较低，缺点（1）爬虫难以保证对代码功能的覆盖率（2）对底层以及 hook 策略依赖较强（3）对环境的强依赖、对执行效率的需求、难以和业务代码结合 SAST-静态代码审计工具，最早期通过关键词正则匹配，一种高覆盖性-宁错杀不放过，典型 Seay，一种高可用性-宁放过不错杀，典型 Rips 近代时期-基于 AST 的代码分析，关键词匹配因为代码开发人员的自由性而不能非常准确，代码不同但是编译器相同，语义分析库如下 https://github.com/nikic/PHP-Parser https://github.com/viraptor/phply 基于 IR/CFG 带有控制流的解决方案是更为主流的，因为 AST 更接近脑中的执行流程， 10月9日 （天气🌧️，心情愉悦✨） 美国网络风暴演习系列活动对我国网络安全工作的启示 协调联动在应急响应中发挥着重要作用 信息共享极为关键，对应急响应效果作用明显 流程机制的完善与迭代是协同防御的重点 等保测评师角度浅谈等保2.0 标准体系制定过程中受安全产品厂家影响较大 标准制定水平较1.0差，重复检验太多、对应测评对象无法测评、缺少可操作性和实践性 10月12号（天气☔️，心情良）leetcode 双指针以及空间保存临时状态是非常经典的方法 基础还是需要打牢 10月27号（天气🌞，心情良）八大看点丨个人信息保护法草案如何捍卫个人信息安全 适用范围更清晰 职责分工更明确 处理个人信息要先取得用户同意 处理敏感信息限制更加严格 突发公共卫生事件中个人信息保护 强化个人信息保护责任和义务 情节严重违法行为处罚可达 5000万 Gartner2020年十大安全项目详解 远程员工安全（零信任网络访问技术） 基于风险的弱点管理 基于平台方式的检测与响应，特指扩展检测与响应（XDR） 云安全配置管理 简化云访问控制，特指云访问安全代理（CASB）技术 基于 DMARC 协议的邮件安全防护 无口令认证 数据分类与保护 员工胜任力评估 安全风险评估与自动化","link":"/2020/09/17/everyday_read/"},{"title":"每日记录","text":"记录每天的收获与总结 2019-08-05 最近确实被保研的事儿弄的有点烦心，但是感觉也算是对自己的一种锻炼吧。事实也告诉我，投机的人确实有，但是真正踏实的师傅总会有所收获。在华为实习已经一个月了，也算是有所收获，本来就是抱着看看工业界的安全是什么样子的想法，能多学点就多学点的态度，总归来说还是不错的。慢慢的从刚来实习时完全不适应的状态（确实和上学差别太大，加上深圳这边天气闷热），到慢慢有了自己的生活节奏，感谢 Bilibili（学习网站）的一些学习 UP 主，让我在工作之余还能有学习状态。 目前主要还是自己内心的一些学习方向的挣扎，确实也体会到了一个人的精力是有限的，不可能面面俱到。不得不说人与人之间的差距真的很大，有些师傅很浮躁，有些师傅就很踏实。希望自己可以不断像踏实的师傅（武师傅、马哥、fish、pupil等）学习。我也希望可以找到自己真正的兴趣，尝试去融入到生活与工作之中。 今天主要还是在学习 Go 语言方面的基础，背了一个 Unit 的英语单词，看了一节日语课。学习了一位很强的师傅挖 CVE 的思路，希望自己多多加油，拿到一个有份量的 CVE。 2019-08-06 从小到大，第一次落枕，太痛苦了。早上起来听到脖子“咔”的一声，瞬间脖子就动不了了，一发力就痛。还得去公司，着实有点痛苦，导致我一天都不在状态，所以说还是要多注意身体，身体不行的话真的干什么都不行。 最近对于实习的任务感觉到不少疑惑，有点怕打扰别人，又十分困惑，还是得多多交流，找回状态。 最近跟着 Bilibili 的一些 UP 主，真是帮助我找回了学习的节奏，真是非常感谢。 2019-08-07 不得不吐槽一下，公司的打卡制度，我回到家里才想起来，好像忘打卡了，导致我又得回去再打一次，有点难受。 每天保持锻炼习惯也有一阵子了，确实效果很不错，整个人锻炼完后就有一种清爽的感觉。 和老妈视频，她觉得我和她联系的太少了。主要我又是一个比较独立的人，遇到什么事情都是自己解决。从事的也不是同一个领域的工作，导致可能确实没什么交流。但是可能还是要多和老妈找找话聊，感觉她感觉好像帮不上我什么忙，很失落。 2019-09-23 好长时间没有记录了，这段时间也是一直在忙自己升学的事情，终于也算有了一个结果。不用在为上学的事情在烦恼了，这种感觉挺好的。每天可以学自己的东西了，希望自己在未来的日子，接着加油吧。 美团面试完后，感觉三面聊的不太好，但是好像最后也还是过了。也算是多了一种选择，看自己的想法了。 最近可以接着学习日语了，以及把服务器好好弄弄。加油吧！ 2021-5-26 在科研的过程中，不要将目标和方法都限制死，要敢于去质疑当前的模型 -李辉老师 论文产出的三要素：学生感兴趣、老师感兴趣、学术界感兴趣 -The Phd Grind 人生不可控、不坚持就不会成功 -The Phd Grind 2021-7-18 对最新文献进行跟踪、文献报告 对某一具体领域的研究、专题报告 一篇文章写好后总结对于这个领域的贡献是什么，解决了什么问题，按照重要性顺序写下来——contribution 比较别人论文优缺点——related work 概括问题与解决方案、可以通过例子——Overview 指出问题很重要，*** insight *** 2021-7-20 针对微博图床加载不了图片的问题，可以在 themes/xxxx/layout/_partials/head.swig 中添加解决 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 这样微博检查不到是否为外链 2021-9-14 德发兴味道确实不错 整体第一天实行计划感觉还是不错的，状态各方面还是不错的 2021-9-15 篮球水平感觉有点陷入舒适区了，应该多多尝试不习惯的打法 今天阅读论文可以找人交流一下 2021-9-16 健身小练😊","link":"/2019/07/08/daily/"},{"title":"Paper 阅读","text":"Everything from paper 论文阅读USENIX SUPOR: Precise and Scalable Sensitive User Input Detection for Android Appsabstract 主要描述做了一个工具 SUPOR，一个对于用户输入的静态检测工具。 Introduction 之前的研究主要集中于智能手机中被操作系统以及架构 API 所管理涉及的隐私信息。忽略了用户的输入，现在很多 app 要求用户输入各种，所以对于用户的输入不能忽视。 主要的识别隐私用户输入的挑战 如何系统识别用户的输入域在 app 的 UI 中 如何识别哪些输入域是敏感的 如何将敏感输入字段与存储他们 value 的应用程序中的变量相关联 分析 UI 隐私分析输入区域通过利用UI渲染，几何布局分析和NLP技术。 ~问：关于这个输入点这个地方，他假设说的是用 HTTP 明文传输。我就在想如果输入点输入的东西用 HTTPS 或者加密了的话，这个寻找输入点是不是没有意义呀～ An Empirical Evaluation of GDPR Compliance Violations in Android mHealth Apps GDPR 三种违规行为 隐私策略不完整 数据收集的不一致 数据传输的不安全 一个是 privacy policy 完整情况，一个是数据的收集范围，一个是传输方式的安全性 对于 GDPR 的对照检测只是做到了基本要求，还有其他可以检测的地方 NLP 技术使用一般，但是他有隐私政策语料库 技术大杂烩的感觉，不过整体方案挺完整的感觉 Polisis: Automated Analysis and Presentation of Privacy Policies Using Deep Learning 整体实现了一个隐私政策查询系统以及一个问答系统，缺乏可用的、可扩展的工具来处理隐私策略的广度和深度 privacy icons 分层次架构 KnIGHT: Mapping Privacy Policies to GDPR 自动对应 privacy policies 与 GDPR，看他符合哪一个片段。 里面有一些工具可以用 学术规范与论文 数学非常重要、研究兴趣、积累论文（数量、质量） 论文精读要达到抛开论文能自己完成所有的推导，自主完成复现，最少 5 遍以上 确定具体研究点、研究的持续性、给予足够重视、积极参与学术活动 标题 反映核心技术 尽量精炼简洁 摘要 标题的扩充 覆盖亮点、出发点、效果 引言 摘要的扩充 研究背景 提出问题及原因 文献调研 本文贡献 参考文献 作者、标题、刊物/会议名称、卷号、页数、月份、年份 不同领域对于参考文献的要求不同 复稿——10遍左右 第二遍细改，理清思路 第三遍速读，调整逻辑 与审稿人打交道 批判接受意见 心存感激 学会忍耐 逻辑、语言、数学（GRE 内容） 一定要主动找老师 实验过程-&gt;结果与讨论-&gt;结论-&gt;引言 返修，按审稿人的问题逐条回复。列出改动的地方，并在正文中标记 GDPR 与 个人信息保护法 对比 目录 GDPR 个人信息保护法 一般规定 总则 原则 一般规定 数据主体的权利 敏感个人信息的处理规则 控制者和处理者 国家机关处理个人信息 个人数据转移 个人信息跨境 独立监督机构 个人信息处理活动的权利 合作和一致性 个人信息处理者的义务 责任和处罚 个人信息保护职责的部分 有关特定加工情况的规定 法律责任 委派行为和执法行为 附则 最后条款 个人数据定义相似，已识别或可识别的自然人有关的各种信息。其中草案定义不包括匿名化的信息。 “处理”的定义，GDPR 定义为对个人数据或个人数据集执行的任何操作或一组操作。草案没有明确定义只是列举了几个操作。 敏感个人数据定义有所不同 GDPR 将敏感个人数据定义为 “特殊类别的个人数据”。种族或民族出身、政治观点、宗教或哲学信仰（或信仰缺失）、工会会员资格、健康，性生活、性取向、生物特征。 一旦泄露或者非法使用，可能导致个人受到歧视或者人身财产安全受到严重危害的个人信息，包括种族、民族、宗教信仰、个人生物特征、医疗健康、金融账户、个人行踪 数据保护原则 GDPR：合法公正透明、目的限制、数据最小化、准确性、存储/保留限制、完整性和保密性 草案：合法公正透明、目的限制、数据最小化、准确性、完整性和保密性 个人主体权利来说，GDPR覆盖面大于草案 GDPR：访问权、纠正权、删除权（被遗忘的权利）、限制处理权、被通知权、携带权、数据可携带权、反对权 草案：访问权、纠正权、删除权、被通知权 自动化决策 整体来说，草案在严谨性以及覆盖面不及 GDPR 个人信息保护法自动化分析小demo 隐私策略的完整性 数据收集的一致性 创新点：删除权 Advances and Open Problems in Federated Learning Achieving Security and Privacy in Federated Learning Systems: Survey, Research Challenges and Future Directions3.1 Byzantine attacks 拜占庭一般问题，指的是分布式系统达成共识中的问题，不一定是恶意的 更新聚合中，加权和平均很容易受到拜占庭攻击 3.2 Model poisoning attacks 与拜占庭相反，攻击者不阻止模型收敛，对手使用的任何攻击策略都必须确保全局模型收敛到在测试集上具有良好性能的点。 防御机制 Detection of malicious clients via model metrics，即根据比较准确率等一系列指标判断，是否让节点参与训练，此时服务器要能够接触数据集 Detecition of malicious clients via update statistics，即根据更新指标判断，超出特定范围的距离的更新将被视为异常更新 Krum aggregation rule，该方法答题思路就是选取方向大致相同的节点进行更新 Coordinate-wise median，中位数更新，中位数是比均值更稳健的统计量（即，它受异常值的影响较小），因此获得的全局模型受潜在恶意对等点的影响较小。 Coordinate-wise trimmed mean，对于均值进行修剪使用 4.Privacy attacks and defenses Honest-but-curious FL server.认真完成聚合，但是会推断相关信息 Malicious FL server.不一定完成聚合工作，还会实行攻击 Honest-but-curious client.可以观察全局参数，去推断别的节点隐私信息 Malicious client.实行攻击的节点 攻击方式 inference attack，推断攻击的范围还是非常广的，方法也有很多 Client-side GAN-based attacks，记录级的 DP 无法防御，生成同样分布的样本。局限性： 分布式架构的改变来引入对抗性影响 多次迭代后，攻击效果可能减弱 攻击只能模仿用于训练的输入数据，而不是来自受害者的确切样本 FL server-side GAN-based attacks，不影响学习过程，影响协作学习过程和不修改共享模型的情况下提高了生成样本的质量，从而实现了隐形攻击。FL 服务器能够区分客户端的身份这一事实能够实现客户端级别的私有数据检索。 抵抗方式 安全多方计算（SMC）：无损、通信成本大、由于不暴露个体参数梯度信息以至于一些类似于krum就无法实施。安全多方计算阻止服务端了解聚合过程中的信息，但是投毒攻击与拜占庭攻击都需要通过服务端分析各个节点的信息，导致之间相互冲突 差分隐私（DP）：有损、使用比较多 DBA: D ISTRIBUTED BACKDOOR ATTACKS AGAINST FEDERATED L EARNING 提出了一种分布式的后门攻击，利用联邦学习的分布式特性。我们在FL 上提出了一种新颖的分布式后门攻击策略DBA，并表明DBA 比集中式后门攻击更持久和有效。基于广泛的实验，我们报告了一个突出的现象，即尽管每个敌手仅通过 DBA 植入了局部触发模式，但与集中式攻击相比，他们组装的模式（即全局触发）在全局模型上获得了显着更好的攻击性能。结果在不同的数据集和不同的攻击场景下是一致的，例如一次性（单次）和连续（多次）中毒设置。据我们所知，本文是研究分布式后门攻击的第一部作品。 Attacker ability：基于 Kerckhoffs 的理论 (Shannon, 1949)，我们考虑这里的强大攻击者，他们完全控制了他们的本地训练过程，例如后门数据注入和更新本地训练超参数 。 这种情况非常实用，因为每个本地数据集通常由本地一方拥有。 然而，攻击者没有能力影响中央服务器的特权，例如改变聚合规则，也不能篡改其他方的训练过程和模型更新。 Objective of backdoor attack：后门攻击旨在误导训练有素的模型在嵌入了攻击者选择的模式（即触发器）的任何输入数据上预测目标标签 τ。 与拜占庭式攻击（Blanchard et al., 2017）不同，后门攻击的目的是操纵局部模型并同时拟合主任务和后门任务，从而使全局模型在 未篡改的数据样本，同时对后门数据样本实现高攻击成功率。 Factors in distributed backdoor attack Trigger size、Trigger gap（距离）、Trigger location、Scale（类似学习率）、Poison ratio（中毒样本比例）、Poison interval（两次中毒之间的间隔）、Data distribution Distributed backdoor attack v.s. centralized backdoor attack 分为两种攻击场景，A-M 和 A-S 即多轮攻击与单轮攻击，Attack A-M 研究成功注入后门的难易程度，而 Attack A-S 研究后门效应减弱的速度 The Robustness of distributed attackBackdoor Attacks and Countermeasures on Deep Learning: A Comprehensive ReviewAbstract 强调了后门攻击的新颖性，提出了本综述的意义 Firstly，针对攻击者能力没有系统分类 Secondly，针对防御方法缺少系统分析与比较 攻击分成 6 类， code poisoning、outsourcing、pertained、data collection、collaborative learning、post-deployment 防御分成 4 类，blind backdoor removal, offline backdoor inspection, online backdoor inspection, and post backdoor removal 后门攻击的另一面：保护深度学习模型的知识产权，充当蜜罐以捕获对抗性示例攻击，以及验证数据贡献者请求的数据删除 A TAXONOMY OF ADVERSARIAL ATTACKS ON DEEP LEARNING DL 容易遭受对抗性攻击，因为黑盒、模型的复杂性、决策的缺乏可解释性 后门攻击是针对深度学习的一种对抗性攻击。 它区别于对抗样本、通用对抗补丁（通用对抗样本/扰动 和数据中毒。 对抗性示例和通用对抗性补丁是规避攻击，仅影响模型部署后的推理阶段。 数据中毒是在数据收集或准备阶段进行的。 然而，后门攻击可以在 ML 管道的每个阶段进行，除了模型测试阶段以保持沉默。 后门攻击相较于对抗性样本更加灵活，可以布局于不同的阶段 UAP 是更加复杂多样的对抗样本，可以视为“幽灵”后门，幽灵的解释是它是深度学习的内在属性，但依然有区别 trigger 是任意的，而精心设计的 UAP 不是任意的。因此，触发器处于攻击者的完全控制之下，而 UAP 则取决于模型 通过后门触发器的攻击成功率通常远高于UAP，尤其是在攻击者更喜欢有针对性的攻击时 数据中毒攻击，降低模型准确性，且无目标，但后门攻击保留了其主要任务的良性样本的推理准确性，并且只有在存在秘密触发器的情况下才会偷偷地进行不当行为，后门攻击通常作为有针对性的攻击来执行——触发器输入被错误地分类为攻击者的目标类别 后门模型学习攻击者选择的子任务和（良性）主要任务的一种方式。 一方面，对于不包含触发器的输入，后门模型通常表现为其干净的对应模型，因此无法仅通过使用测试样本检查测试准确性来区分后门模型和干净模型。 这与上面的中毒攻击不同，它恶化了主要任务的整体准确性，因此引人注目（和可疑）。 另一方面，一旦输入中出现秘密触发器，后门模型就会被误导以执行攻击者的子任务，例如，即使与输入的原始内容无关。 BackgroundA. Attack Surface code poisoning：使用第三方库从而导致的代码层面攻击 outsourcing(外包)：恶意 MLaaS 提供商控制训练阶段并在训练过程中对 ML 模型进行后门处理。 pertrained:当重复使用预训练模型或“教师”模型时，会引入此攻击面 data collection:数据收集通常容易出错并且容易受到不可信来源的影响 collaborative learning:作学习容易受到各种攻击 ，包括后门攻击。当极少数参与者受到攻击者的危害或控制时，联合学习的模型很容易被后门。如果使用参数加密技术是无法检查数据或者模型的 post-deployment:ML 模型已经部署，特别是在推理阶段，考虑一个典型的攻击场景，其中攻击者和用户是共享同一服务器的两个进程。 用户启动 ML 模型并将 ML 权重加载到内存中。 攻击者通过触发 rowhammer 错误 [80] 间接翻转权重的位 B. Backdoor Variants Class-specific and class-agnostic：后门攻击一般是有目标的🤔，后门攻击可以分为类不可知（当触发效果独立于源类时）和特定于类的攻击（当触发效果依赖于源类时）。对于前者，后门模型可以将来自任何带有触发器标记的类的输入错误地分类为目标类。也就是说，触发器的存在主要决定了攻击。至于后者，后门模型可能会将来自带有触发器标记的特定类的输入错误分类为目标类。也就是说，触发器的存在以及特定的类决定了攻击。 Multiple tirggers to same label：多个触发器对应一个标签，多个触发器中任何一个触发器的存在都可以将后门模型劫持到相同的目标标签 Multiple Triggers to Multiple Labels：在这种情况下，后门模型可以被多个触发器劫持；但是，每个触发器针对不同的标签 C. Backdoor Preliminary Clean Data Accuracy(CDA)：不含触发器的干净测试样本，这些样本被正确预测到它们的真实类别的比例 Attack Success Rate(ASR)：包含触发器的干净测试样本，这些样本被预测到攻击目标标签的比例 Backdoor AttacksA. Outsourcing Attack Invisible Trigger：我们注意到隐形导致触发器更像是添加的噪音。在很大程度上，对抗样本的防御可以应用于防御这种隐形后门攻击。有几种有效的对抗性示例对策，例如特征压缩 、输入转换 、降噪，可用于击败此类隐形触发攻击。 Backdoor Reinforcement Learning：后门顺序模型，一个区别是触发器的呈现方式和后门行为的激活方式。在以前的后门分类任务中，后门效应在触发器出现时立即激活，一旦没有触发器就消失。相比之下，杨等人。 证明动作可以与后门顺序模型中触发器的存在不同步——对抗性动作可以是几个步骤之后。此外，触发器只出现很短的一段时间——例如，在特定的步骤，但如果触发器消失，后门行为将继续。这两个属性可能会使触发器检测更加艰巨，因为即使确实注意到了对抗性动作，也无法将触发器与对抗性动作联系起来 总结：外包增强了攻击者能力，他可以接触训练数据和模型，控制 trigger 和训练过程，值得一提的是，攻击者始终可以将防御目标的规避纳入损失函数，以自适应地绕过现有的对策 B. Pretrained Attack 用户的数据或/和计算资源很少，无法训练准确的模型。 因此，用户将使用公共或第三方预训练模型来提取一般特征。 Trojan Attack：严格来说，这种攻击并没有专门针对受害者训练学生模型的迁移学习——在某种程度上，属于外包攻击面。它利用已发布的模型来加速后门过程，并期望受害者直接使用重新分发的后门模型。尽管如此，结果表明，如果后来的受害者确实采用这种后门模型进行迁移学习，触发输入的模型准确性将在一定程度上降低——扰乱其正确行为。然而，由于攻击者不知道新任务的输出标签，触发器输入无法将新模型误导到目标标签。 Model Reuse Attack：攻击者确实需要知道下游任务和用户使用的小数据集。与任何带有触发器标记的输入都会被错误分类的传统后门攻击相比，模型重用攻击似乎仅适用于有限的对抗性输入 Programmable Backdoor Latent backdoor：思路大概是攻击未来的标签，攻击感染预训练的教师模型。通常，潜在后门是注入教师模型的“不完整”后门——攻击者目标标签 尚不存在于教师模型中。但是，如果任何学生模型包含，则迁移学习过程会自动完成后门并使其处于活动状态。 Appending backdoor：总的来说，它通过将另一个单独的后门（小）神经网络与目标模型附加或合并来实现。 因此，它不会篡改目标模型的参数。 作为权衡，这项工作必须改变模型架构。 在实践中，架构变化并不隐蔽。 因此，只需检查模型架构规范即可轻松检测到 GNN backdoor 总结：然而，攻击者无法控制下游任务和用户采用的迁移学习策略。 ASR 通常不如外包后门攻击高。 至于潜在的后门 ，ASR 很容易被破坏。 值得一提的是，预训练后门攻击或多或少假设了下游任务的特定知识（可能是推测的）和下游任务的一小部分数据 C. Data collection attack 需要中毒数据更加隐蔽，特别是为了欺骗人类检查。 然而，攻击者无法控制和操纵训练过程或最终模型 Clean-Label Attack（怎么感觉和对抗样本有点像🤔）：保留中毒数据的标签，看起来仍是一个良性样本。对于清洁标签攻击，我们注意到触发器是一组特定的（测试）图像样本，而不是通用的特定模式。换句话说，后门攻击仅适用于一个或一小组输入——注意预训练下的模型重用攻击实现了类似的后门效果。这种隐藏的后门攻击似乎更实用和更强大，因为可见的推理触发器仅在攻击出现时才会显示，但在数据中毒期间通过不可见的中毒触发器隐藏。这些清洁标签攻击假设受害者了解模型 Targeted class data poisoning：数据中毒引入的传统后门，它随机 i) 从不同的源类别中选取训练样本，ii) 标记触发器，以及 iii) 将它们的标签修改为目标类别。提出了基于 GAN 和对抗性扰动来注入后门。为了对 ASR 有效，攻击者需要对模型架构和后期训练过程有充分的了解 Image-Scaling Attack：这滥用了人类（篡改的“羊”形象）和机器（“狼”形象）之间对同一形象的不一致理解。因此，可以有效且隐蔽地利用缩放伪装在黑盒设置下执行后门攻击；一般来说，触发图像可以伪装成目标类别的图像，通过执行图像缩放攻击来毒化训练数据，从而对训练模型进行后门处理。在推理阶段，触发器现在可以轻松激活后门模型，而无需使用缩放攻击。 总结：对于中毒的数据，由于其内容始终与标签一致，因此在进行人工或目视检查时很难区分。 因此，不仅端到端训练的模型而且迁移学习都可能受到感染。 特征冲突是制作标签一致的有毒输入以注入后门的常用方法。 但是，在某些情况下，需要了解受感染模型架构的一些知识才能确定适当的潜在表示 D. Collaborative learning attack 结果表明，即使仅在一轮（单次攻击）中选择单个客户端为联合模型更新做出贡献，联合模型在插入后门后立即具有 100% 的 ASR。随着联合模型继续学习，ASR 确实会减少。通过控制不超过 1% 的客户端，联合模型与干净模型的准确度相当，现在无法防止后门被遗忘。由于原则上不允许访问数据，因此要击败联邦学习的后门攻击非常具有挑战性。拜占庭弹性聚合策略对此类攻击无效。更糟糕的是，当采用安全聚合来进一步增强隐私时，防御会变得更加困难 总结：一方面，协作学习越来越被使用。 另一方面，由于很难控制恶意参与者提交的数据和本地模型，因此它天生容易受到后门攻击。 E. Post-Deployment Attack F. Code poisoning Backdoor countermeasuresA. Blind Backdoor Removal 不区分后门模型与干净模型，或从干净输入触发输入。 主要目的是消除或抑制后门效应，同时保持干净输入的 CDA，特别是考虑到它最终是一个干净的模型。 Fine-Pruning：修剪 DNN 模型中精心选择的对主要分类任务贡献最小的神经元来移除潜在的后门 。 更准确地说，神经元根据它们在干净输入（例如，保持验证样本）上的激活进行排序，并以最少激活的顺序进行修剪。 一种普遍的假设是，由清洁和触发输入激活的神经元是不同的或可分离的。 修剪后，微调用于恢复模型性能。 Februus：利用视觉解释工具来识别潜在的触发区域。 一旦确定该区域，Februus 将手术移除恶意区域并将其替换为中性灰色。 这种手术去除步骤已经消除了触发效应，并可能降低深度神经网络的分类。 提出了一个额外的步骤，即图像恢复，使用基于 GAN 的图像修复方法将受损区域恢复到被污染之前的原始可能性。 该方法对多个后门变体具有鲁棒性，尤其是针对特定类别的后门变体。 然而，由于该方法涉及删除和恢复图像，它对大尺寸敏感 Suppression：给定每个输入，制作了许多副本：每个副本都通过添加一些噪声而受到干扰——噪声水平是凭经验确定的。所有被扰动的副本都被输入到 DNN 模型中，无论是后门的还是干净的，以收集预测。 ConFoc：基本原理是图像由内容和样式信息组成[138]。前者是指物体的形状或语义信息，后者是指图像的颜色或纹理信息。据推测，在进行分类时，仅关注内容类似于人类的推理。因此，ConFoc 重新训练模型进行分类，主要依靠内容信息。 ConFoc 的一个主要限制是它假设触发器不与输入图像中感兴趣的对象（具有内容信息）重叠，这在设置触发器与对象重叠时不适用 RAB：尽管可证明的鲁棒性是可取的，但 RAB 有严格的条件，例如触发器扰动界限必须很小，这意味着只要触发器的扰动超过界限，它就可以在实践中轻松绕过。此外，还有许多“平滑”模型需要训练，这大大增加了计算开销。此外，为了保证可证明的鲁棒性，RAB 需要了解中毒数据的比例和扰动边界类型，例如 l2 范数，这往往是不切实际的。 B. Offline Inspection ​ 1）Data Inspection Spectral Signature：当干净输入的潜在表示与触发输入的潜在表示完全不同时，这种防御就会成功。因此，一个关键的步骤是确定获得适当潜在表征的方法，以暴露触发器的踪迹 。但是，它指出异常值比率固定为接近目标类中损坏样本的比率 Gradient Clustering：假设然后证明触发图像样本可能导致输入层在触发位置的梯度绝对值相对较大。 基于此，可以使用聚类算法将触发样本与干净样本分开。 由于作者可以检测受感染的目标和源类别，因此可以通过将触发样本重新标记为正确的标签来重新训练受感染的模型，以消除后门效应，而不是使用已删除损坏数据的净化数据从头开始训练模型。 Activation Clustering：最后一个隐藏层的激活反映了神经网络用于达到模型决策的高级特征。给定收集到的数据和用数据训练的模型，将每个样本输入模型，并收集相应的激活。通过在降维后应用 k = 2 的 k 均值聚类，将属于同一标签的输入的激活分离和聚类。由于 2-means 聚类总是将激活分成两个簇，无论是否存在中毒数据，都会使用一些度量来判断。例如，高剪影分数意味着该类已被感染或中毒。一旦识别出中毒数据，就可以将其删除，并训练一个干净的模型。 Deep KNN：设计一个深度 k-NN检测清洁标签中毒样本的方法，可以有效对抗特征碰撞和凸多面体清洁标签攻击 SCAn：攻击者目标类（受感染类）中图像的潜在表示是来自触发输入和干净输入的两组的混合。每个都被分解为不同的身份和通用变化组件。回想一下，触发图像来自不同的类别/身份，但（错误）标记到目标标签。以便可以识别受感染的类。 SCAn 还有一个额外的主要优势，它也适用于特定于类的触发器。作为一个轻微的矛盾，它最终假设一小组保持干净的验证集，必须不包含触发器，从这个数据收集表面下的内部收集。SCAn 对多目标触发攻击的效果较差。 DP：模型已经极大地抑制了后门效应——ASR 非常低。此外，模型在预测非典型中毒示例时的信心也会降低。因此，通过将损失作为度量来衡量，可以区分中毒输入，因为它具有更高的损失分数。 ​ 2）Model Inspection Trigger Reverse Engineer：NeuralCleanse 遍历模型的所有标签，并确定是否有任何标签需要更小的修改来实现错误分类。这种方法的一个优点是可以在后门模型检测过程中对触发器进行逆向工程和识别。一旦触发被识别，后门移除可以通过重新训练来消除触发效应。但 NeuralCleanse 仍然有一些限制。首先，它可能会产生与标签数量成正比的高计算成本。对于特定的 DNN 模型，即使考虑了优化，检测过程的计算成本也可能需要几天时间。当任务的类数很大时尤其如此。其次，与大多数后门对策一样，据报道，随着触发器大小的增加，该方法的效果较差。第三，它需要训练参考模型来确定一个（全局）阈值来区分干净模型和后门模型，这在外包下无意中似乎不适用。因为这违反了外包的动机，因为用户的计算资源或/和 ML 专业知识有限。 DeepInspect：DeepInspect 的关键思想是使用条件生成模型来学习潜在触发器的概率分布。 该生成模型将用于生成反向触发器，其扰动水平将被统计评估以构建后门异常检测。 AEGIS：将输入样本与其潜在表示进行聚类并不是什么新鲜事，它已被用于触发数据检查 。不同之处在于之前的工作需要访问中毒的触发数据，而 AEGIS 则不需要。 AEGIS 的局限性仅适用于稳健模型，不适用于标准模型。人们还承认，击败特定触发器，例如混合触发器，诱导后门似乎是 AEGIS 的一个挑战 Meta classify：它由防御者训练许多干净的和后门影子模型作为元分类器（另一个神经网络）的训练样本，以预测新模型是否干净。当数据集发生变化时，必须执行这种计算成本高的阴影模型训练。 总结：由于防守方的能力较差，尤其是由于无法访问中毒样本，因此离线模型检查通常需要高计算开销和 ML 专业知识也就不足为奇了。 在这种情况下，外包和预训练的防御者可能无法采取这些对策。 C. Online Inspection ​ 1）Data Inspection STRIP：一方面，对于干净的输入，预测 z 应该与真实情况大不相同，因为对其施加了强而有意的扰动。因此，具有不同扰动的干净输入的副本表现出很强的随机性——通过熵度量量化。另一方面，对于触发器输入，由于触发器的强劫持效应，即使在扰动下，预测 z通常也应该与攻击者的目标 保持恒定。因此，具有变化扰动的触发器输入的副本表现出弱随机性。给定一个预设的熵阈值——可以单独使用干净的输入来确定，触发输入（高熵）可以很容易地与干净的输入（低熵）区分开来。STRIP 的一个限制是它主要是为类不可知的触发器而设计的，而这些触发器对于类特定的触发器是无效的。 Epistemic classifier：它通常基于这样的假设，即具有触发器的输入可能从输入层中的源类开始接近干净的训练实例，但其在神经网络上的轨迹将缓慢或突然接近攻击者选择的目标类。 ​ 2）Model Inspection ABS：使用 ABS 检查单个神经元激活差异以检测后门异常，这可以潜在地击败对序列模型 超出分类任务的后门攻击。 ABS 的优势在于 i）它与触发器大小无关，并且 ii）每个标签只需要一个干净的训练输入来检测后门。 iii) 它还可以检测对特征空间而不是像素空间的后门攻击。然而，该方法似乎仅在某些关键假设下有效，例如，目标标签输出激活只需要由一个神经元激活，而不是由一组神经元的相互作用激活。因此，它可以通过使用中的扩展触发器轻松绕过。此外，范围也仅限于每个标签一个触发器的攻击。如果多个触发器旨在攻击同一个标签，那么 ABS 将无法实现。 NIC：这种方法通常可以被视为检查跨 DNN 层的激活分布和流（受编程中使用的控制流的启发），以确定是否由于对抗样本而违反了流。 总结：在线检查的一个优点是一些对策对触发大小不敏感。 此外，在线检查对策在某种程度上具有对不同领域的良好泛化。 一个限制是在线检查通常会导致延迟。 D. Post Backdoor Removal 一旦通过模型检查或数据检查检测到后门，就可以考虑删除后门。一种方法是删除损坏的输入并再次训练模型，这似乎仅在数据收集下才实用，因为不允许用户在其他攻击面下访问触发器输入。另一种方法是通过使用包含触发器但正确标记的损坏数据重新训练或微调后门模型，从模型中去除后门行为，重新学习更正的决策边界。 Flip Slide of Backdoor Attack watermarking：目前有一些作品将后门作为水印来保护受过训练的 DNN 模型的知识产权（IP）。论点是插入的后门可用于声明模型提供者的所有权，因为应该只有提供者知道这样的后门。相比之下，后门 DNN 模型在正常输入上没有（或察觉不到）功能性能下降。尽管有多种对抗后门插入的检测、恢复和移除对策，但我们推测使用后门技术的水印通常是稳健的。理由是开发一对多的后门对策非常具有挑战性。但是，我们建议始终考虑谨慎的后门插入策略来为模型添加水印，尤其是考虑到自适应后门插入。利用后门作为信息隐藏技术或速记技术是可行的。 against model extraction：当攻击者查询旨在窃取主任务功能的模型时，作为不同子任务的水印可能不会传播到被盗副本。 against adversarial examples：类似于蜜罐🍯 data deletion verification：验证用户删除，ASR 可以检查后门跟踪，如果数据删除得到遵守，后门跟踪应该非常低。因为现在应该在没有用户数据的情况下训练模型，也没有数据中包含的后门痕迹。 Discussion and prospect 自适应攻击 Backdoor Learning: A SurveyIntroduction 这篇文章中将防御方法分类成基于经验以及经过认证的两种，个人觉得没有上一篇根据防御者能力分类的效果好。 它主要分析三个场景 第三方数据源 第三方平台 第三方模型 Poisoning-based backdoor attacks NEURAL ATTENTION DISTILLATION: ERASING BACK - DOOR TRIGGERS FROM DEEP NEURAL NETWORKSAbstract NAD 利用教师网络指导后门学生网络在一个小的干净数据子集上的微调，使学生网络的中间层注意力与教师网络的中间层注意力保持一致。教师网络可以通过对同一个干净子集的独立微调过程获得。我们凭经验表明，针对 6 种最先进的后门攻击，NAD 可以仅使用 5% 的干净训练数据有效地消除后门触发器，而不会导致干净示例的明显性能下降。 Introduction attention maps 可以作为一种直观的方式来评估后门防御机制的性能，因为它们能够突出显示网络拓扑中的后门区域 knowledge distillation 知识较多的网络称为教师网络，较小的网络称为学生网络。 特征图和注意力机制已被证明在 KD 中非常有用，可以监督学生网络的训练。 Proposed approach NAD 与传统微调方法之间的差异。 我们没有将微调网络直接用作我们的最终模型，而是将其用作教师网络，并通过将其与原始后门网络（即学生网络）结合使用注意力蒸馏过程。","link":"/2019/07/08/paper/"},{"title":"leetcode recode","text":"三百六十五个日子里 leetcode_recode main programming language: C++ 1. Two SumEasy Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 分析： 我们可以建立一个 unorded_map 来存储数组里面每个值以及它所对应的位置关系。 我们用 other_num = target - nums[i]。然后如果不是重复元素，就去找是否存在，如果存在就直接压入 vector。如果是重复元素，就遍历整个 vector 来找到位置，返回。 mySolution: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int,int&gt; result; vector&lt;int&gt; return_back; int i = 0; for(i = 0;i &lt; nums.size();i++) { result.insert({nums[i],i}); } for(i = 0;i &lt; nums.size();i++) { int flag = 0; auto other_num = target - nums[i]; if(other_num != nums[i]) { auto it = result.find(other_num); if(it == result.end()) { continue; } else { return_back.push_back(i); return_back.push_back(it-&gt;second); flag = 1; } if(flag == 1) { break; } } else { if(count(nums.begin(),nums.end(),other_num) &gt; 1) { for(i = 0;i&lt;nums.size();i++) { if(nums[i] == other_num) { return_back.push_back(i); } } } else { continue; } } } return return_back; }}; 2. Add Two NumbersMedium You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 分析： 这题是一个链表的形式的加法题 整体就是一个加法进位，一个加法余位，两个位置分别保存。这题主要是长度的分类，我自己的思路就是对于较长的链表遍历完才结束遍历。对于短的链表就不停的加值为 0 的结点。 mySolution: 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int l1_num = 0,l2_num = 0,sum_result = 0,carry = 0; ListNode *head = l1; while(1) { sum_result = (l1-&gt;val + l2-&gt;val + carry) % 10; carry = (l1-&gt;val + l2-&gt;val + carry) / 10; l1-&gt;val = sum_result; if(l1-&gt;next == NULL &amp;&amp; l2-&gt;next != NULL) { l1-&gt;next = new ListNode(0); } else if(l1-&gt;next != NULL &amp;&amp; l2-&gt;next == NULL) { l2-&gt;next = new ListNode(0); } else if(l1-&gt;next == NULL &amp;&amp; l2-&gt;next == NULL) { if(carry) { l1-&gt;next = new ListNode(carry); } break; } l1 = l1-&gt;next; l2 = l2-&gt;next; } return head; }}; 3. Longest Substring Without Repeating CharactersMedium Given a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 分析： 这题是一个最长字符子串的问题。我个人想法使用一个字典来记录某字符出现次数。 我们用 i、j 指向头部，不断增加 j 的大小，不断增加字典中字符的次数，如果出现某一个字符串出现次数大于两次，就不断移动 i 直到没有重复字符串为止。最后 maxlen 不停更新为最大的值。 mySolution: 12345678910111213141516171819class Solution {public: int lengthOfLongestSubstring(string s) { unordered_map&lt;char,int&gt; sub_m; int i = 0,j = 0; int maxlen = 0; for(i = 0,j = 0;j&lt;s.size();j++) { ++sub_m[s[j]]; while(sub_m[s[j]] &gt; 1) { sub_m[s[i]]--; i++; } maxlen = max(maxlen,j-i+1); } return maxlen; }}; 4. Median of Two Sorted ArraysHard There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 分析： 这题我个人的思路是非常蠢的。。。先合并，在排序，在去取值 我在写这个文档的时候，也是不知道当时做这题是怎么想的。为什么用这种奇怪的方法，复杂度还高。 ！去看一下 find_k 算法 mySolution: 1234567891011121314151617181920212223242526272829class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int i = 0,j = 0; nums1.insert(nums1.end(), nums2.begin(), nums2.end()); multiset&lt;double&gt; num(nums1.cbegin(), nums1.cend()); multiset&lt;double&gt;::iterator set_it = num.begin(); double result = 0; if (nums1.size() % 2 == 0) { i = (nums1.size() / 2) -1; for (j = 0; j &lt; i; j++) { ++set_it; } result = (*set_it + *(++set_it)) / 2; } else { i = (nums1.size() - 1) / 2; for (j = 0; j &lt; i; j++) { ++set_it; } result = *set_it; } return result; } }; 5. Longest Palindromic SubstringMedium Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 分析： 这题我自己的做法，也是非常传统的想法实现，没有任何编程方面的技巧，就是硬想出来的 设置边界，需要找到相关的边界，来进行记录。首先跳过中间相同的字符，因为这个不影响是不是回文字符串 然后利用回文字符串的规则，进行比较，如果符合，就接着遍历。同时记录相关的位置信息 最后利用 substring 返回子字符串 mySolution: 1234567891011121314151617181920212223242526272829303132class Solution {public: string longestPalindrome(string s) { int low_bound = 0,high_bound = 0,max_len = 0,temp = 0,result_low = 0; if((s.empty()) || (s.size() == 1)) { return s; } else { for(int i = 0;(high_bound+1) &lt; s.size() &amp;&amp; max_len &lt;= s.size();) { low_bound = i; high_bound = i; while(s[high_bound] == s[high_bound + 1] &amp;&amp; (high_bound + 1) &lt; s.size()) { i = high_bound + 1; ++high_bound; } for(;low_bound &gt; 0 &amp;&amp; (high_bound+1) &lt; s.size() &amp;&amp; s[low_bound - 1] == s[high_bound + 1];--low_bound,++high_bound); temp = high_bound -low_bound + 1; if(temp &gt; max_len) { max_len = temp; result_low = low_bound; } i++; } return s.substr(result_low,max_len); } }}; 6. ZigZag ConversionMedium The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); Example 1: 12Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot; Example 2: 12345678Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I 分析： 感觉自己在前期做题的时候，确实没有想任何相关的编程技巧。都是自己想逻辑，然后自己把实现了。 这个自己的思路，就是申请一个 vector 来按一定的规则来存放传入的 s，因为我们看 Explanation 可以发现，这就是一种存储规则 存储完后，在用 for-each 循环再传入到一个result就可以了。 mySolution: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: string convert(string s, int numRows) { vector&lt;string&gt; result(numRows); string::iterator in = s.begin(); if (numRows &gt; 1) { int cycle_num = 2 * numRows - 2; for(int i = 0;i&lt;cycle_num;) { if(in != s.end()) { if(i &lt; numRows) { result[i] += *in; ++in; ++i; i = i%cycle_num; } else { result[cycle_num - i] += *in; ++in; ++i; i = i%cycle_num; } } else { break; } } string result_str; for(auto i : result) { result_str += i; } return result_str; } else { string result_str = s; return result_str; } }}; 7. Reverse IntegerEasy Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 分析： 感觉自己也是挺赖的，用了 to_string 转字符串，然后还用了 stoi 转会 int。可能第一遍刷的时候确实只是在解决问题，却不是最好的解决问题。 这题也就是简单的情况判断。大于 0 以及 小于 0 的情况，末尾几位为 0 的情况，最后如果溢出如何操作。 mySolution: 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: int reverse(int x) { int i = 0; int temp = x; string int_string = to_string(x); int result = 0; while (temp != 0) { if ((temp % 10) == 0) { ++i; temp = temp / 10; } else { break; } } if (x &gt;= 0) { std::reverse(int_string.begin(), int_string.end() - i); } else if (x &lt; 0) { std::reverse(int_string.begin() + 1, int_string.end() - i); } string result_string(int_string,0,int_string.size()-i); try { result = std::stoi(result_string); } catch(std::out_of_range err) { return 0; } return result; }}; 8. String to Integer (atoi)Medium Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned. Example 1: 12Input: &quot;42&quot;Output: 42 Example 2: 1234Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: 123Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: 1234Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: 1234Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 分析： 依然是自己硬想的逻辑，真的是太菜了。。。 这个题目也是不断的逻辑处理。先是删除掉前面的所有空格。分正负情况，将数字提取出来，然后判断有没有溢出，就完成了。 mySolution: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115class Solution {public: int myAtoi(string str) { int result = 0; string s; if(str.empty()) { return 0; } else { str.erase(0,str.find_first_not_of(&quot; &quot;)); if(str[0] &gt;= '0' &amp;&amp; str[0] &lt;= '9') { int i = 0; while(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9' &amp;&amp; i &lt;str.size()) { ++i; } s = str.substr(0,i); s.erase(0,s.find_first_not_of(&quot;0&quot;)); if(s.empty()) { return 0; } if(s.size() &gt;= 10) { if(s.size() &gt; 10) { return 2147483647; } else { if(s &gt; &quot;2147483647&quot;) { return 2147483647; } } } for(i = 0;i &lt; s.size();i++) { result = (result * 10 + (s[i] - '0')); } return result; } else if(str[0] == '-') { int i = 1; while(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9' &amp;&amp; i &lt; str.size()) { s += str[i]; ++i; } s.erase(0,s.find_first_not_of(&quot;0&quot;)); if(s.empty()) { return 0; } if(s.size() &gt;= 10) { if(s.size() &gt; 10) { return -2147483648; } else { if(s &gt;= &quot;2147483648&quot;) { return -2147483648; } } } for(i = 0;i &lt; s.size();i++) { result = result * 10 + (s[i] - '0') ; } return -result; } else if(str[0] == '+') { int i = 1; while(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9' &amp;&amp; i &lt; str.size()) { s += str[i]; ++i; } if(s.size() &gt;= 10) { if(s.size() &gt; 10) { return 2147483647; } else { if(s &gt;= &quot;2147483647&quot;) { return 2147483647; } } } for(i = 0;i &lt; s.size();i++) { result = result * 10 + (s[i] - '0') ; } return result; } else { return 0; } } }}; 9. Palindrome NumberEasy Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 分析： 虽然题目说不要使用 integer to a string，但是那样自己想的办法也就是取出每一位，然后重新构造一个数，看是否相等。 我这里直接也就直接转 string 然后 reverse 判断是否相等。 mySolution: 12345678910111213141516class Solution {public: bool isPalindrome(int x) { auto str_x = std::to_string(x); std::string str_y(str_x); reverse(str_y.begin(),str_y.end()); if(str_x == str_y) { return true; } else { return false; } }}; 10. Regular Expression MatchingHard Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. 12'.' Matches any single character.'*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;. Example 3: 12345Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4: 12345Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;. Example 5: 1234Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false 分析 ： 这题我个人觉得也是非常好，刚开始结合自己刚刚学习编译原理的原因，想弄个递归下降子程序，以及弹栈的思想。后来发现 * 不是很好处理，所以干脆直接递归处理，这也算是动态规划了吧。 首先将一些能直接返回的情况，判断完。然后就涉及到一些需要进一步判断的情况。 正常的字母匹配都不是关键的地方，这题的难度在于 .* 以及 [a-z]* 的 处理。 对于 [a-z]* 。因为 * 可以不匹配，所以我们还要判断不匹配的情况，是否能成功。这里直接使用递归，然后如果不匹配不成功的话，然后我们就需要接着判断到底匹配几个，这里又需要我们写循环，再循环里我们需要递归判断。成功的话，直接返回就好了。 对于 .* 。同样也是要判断表示是否匹配，以及匹配几个的问题。所以同样是递归来进行判断。 mySolution: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154class Solution {public: bool isMatch(string s, string p) { if(s.empty() &amp;&amp; p.empty()) { return true; } if(s.empty() &amp;&amp; (!p.empty())) { if(p.size() % 2 != 0) { return false; } else { for(int i = 1;i &lt; p.size();i += 2) { if(p[i] != '*') { return false; } } return true; } } if((!s.empty()) &amp;&amp; p.empty()) { return false; } int i = 0,j = 0; for(i = 0, j = 0;i &lt; s.size() &amp;&amp; j &lt; p.size();) { if(j != (p.size()-1)) { if(p[j] &gt;= 'a' &amp;&amp; p[j] &lt;= 'z') { if(p[j+1] &gt;= 'a' &amp;&amp; p[j+1] &lt;= 'z') { if(s[i] == p[j]) { ++i; ++j; } else { return false; } } else if(p[j+1] == '*') { while((j+3) &lt; p.size()) { if(p[j + 2] == p[j] &amp;&amp; p[j+3] == '*') { j += 2; } else { break; } } if(isMatch(s.substr(i),p.substr(j+2))) { return true; } else { while(s[i] == p[j]) { if(isMatch(s.substr(i),p.substr(j + 2))) { return true; } ++i; } j+=2; } } else if(p[j+1] == '.') { if(s[i] == p[j]) { ++i; ++j; } else { return false; } } } else if(p[j] == '.') { if(p[j+1] &gt;= 'a' &amp;&amp; p[j+1] &lt;= 'z') { ++i; ++j; } else if(p[j+1] == '*') { if(p.substr(j + 2).empty()) { return true; } else { while(i &lt;= s.size()) { if(isMatch(s.substr(i),p.substr(j+2))) { return true; } ++i; } return false; } } else if(p[j+1] == '.') { ++i; ++j; } } } else if(j == p.size() - 1) { if(i == s.size() -1) { if((p[j] == '.') || (s[i] == p[j])) { return true; } else { return false; } } else { return false; } } } if(isMatch(s.substr(i),p.substr(j))) { return true; } else { return false; } }}; 11. Container With Most WaterMedium Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: 12Input: [1,8,6,2,5,4,8,3,7]Output: 49 分析： 这题就是一个数学题吧，整体思路也比较清晰。 首先从头尾开始往中间进行遍历，因为宽度一直在减小，如果高度还减小，肯定是没有前种情况大的。所以我们一直遍历到，高度比前面大的情况。可以大大减少时间复杂度。 mySolution: 12345678910111213141516171819202122class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int i = 0,j = (height.size()-1); int min_height = 0; int water = 0; while(i &lt; j) { min_height = min(height[i],height[j]); water = max(water,min_height * (j-i)); while(height[i] &lt;= min_height &amp;&amp; i&lt;j) { ++i; } while(height[j] &lt;= min_height &amp;&amp; i&lt;j) { --j; } } return water; }}; 12. Integer to RomanMedium Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: 3Output: &quot;III&quot; Example 2: 12Input: 4Output: &quot;IV&quot; Example 3: 12Input: 9Output: &quot;IX&quot; Example 4: 123Input: 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3. Example 5: 123Input: 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 分析： 同样是正常的分类逻辑，完成逻辑即可 mySolution: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class Solution {public: string intToRoman(int num) { string result; for(;num &gt;= 1000;num = num - 1000,result += &quot;M&quot;); for(;num &gt;= 500;) { num = num - 500; if(num / 100 == 4) { result += &quot;CM&quot;; num = num - 400; } else { result += &quot;D&quot;; } } for(;num &gt;= 100;) { if(num / 100 == 4) { result += &quot;CD&quot;; num = num - 400; } else { num = num - 100; result += &quot;C&quot;; } } for(;num &gt;= 50;) { num = num - 50; if(num / 10 == 4) { result += &quot;XC&quot;; num = num - 40; } else { result += &quot;L&quot;; } } for(;num &gt;= 10;) { if(num / 10 == 4) { result += &quot;XL&quot;; num = num - 40; } else { result += &quot;X&quot;; num -= 10; } } for(;num &gt;= 1;) { if(num &gt;= 5) { if(num % 5 == 4) { result += &quot;IX&quot;; num -= 9; } else { num = num % 5; result += &quot;V&quot;; } } else { if(num == 4) { result += &quot;IV&quot;; break; } else { result += &quot;I&quot;; num--; } } } return result; }}; 13. Roman to IntegerEasy Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: &quot;III&quot;Output: 3 Example 2: 12Input: &quot;IV&quot;Output: 4 Example 3: 12Input: &quot;IX&quot;Output: 9 Example 4: 123Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3. Example 5: 123Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 分析： 用两个 vector 来存储相关的字符与数字的对应关系。 我们整体逻辑就是取位置的差距，然后去另一个 vector 找对应的值。当然要判断是不是特殊情况，整体逻辑也不是很难。 mySolution: 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int romanToInt(string s) { int num_result = 0; vector&lt;char&gt; roman_char{ 'I','V','X','L','C','D','M' }; vector&lt;int&gt; romen_int{ 1,5,10,50,100,500,1000 }; string::reverse_iterator in = s.rbegin(); vector&lt;char&gt;::iterator iter = find(roman_char.begin(), roman_char.end(),*in); auto dis = distance(roman_char.begin(), iter); int temp = dis; num_result += romen_int[dis]; ++in; for (unsigned int i = 1; i &lt; s.size(); i++) { iter = find(roman_char.begin(), roman_char.end(), *in); dis = distance(roman_char.begin(), iter); if (dis &gt;= temp) { num_result += romen_int[dis]; temp = dis; ++in; } else { num_result -= romen_int[dis]; temp = dis; ++in; } } return num_result; }}; 14. Longest Common PrefixEasy Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &quot;&quot;. Example 1: 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 123Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. 分析： 首先取所有字符串的最短长度 然后我们从 0 开始遍历，直到找到不是公共子串的长度。 mySolution: 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if(strs.empty()) { return &quot;&quot;; } else { int min_size = strs[0].size(); int flag = 0; string result; for(auto i : strs) { if(i.size() &lt; min_size) { min_size = i.size(); } } for(int j = 0;j &lt; min_size;++j) { string temp = strs[0].substr(0,(j+1)); flag = 0; for(auto str:strs) { if(str.substr(0,(j+1)) != temp) { ++flag; } } if(flag == 0) { result = temp; } } return result; } }}; 15. 3SumMedium Given an array nums of n integers, are there elements a, b, c in numssuch that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 分析： 这题我们需要将数组进行排序来减小时间复杂度 然后我们固定一个位置，将整个问题变成一个子问题。子问题就是在子数组里面找到对应的和为要求值的位置。然后不断增加 i 即可。 mySolution: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; num) { vector&lt;vector&lt;int&gt; &gt; res; std::sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) { int target = -num[i]; int front = i + 1; int back = num.size() - 1; while (front &lt; back) { int sum = num[front] + num[back]; if (sum &lt; target) front++; else if (sum &gt; target) back--; else { vector&lt;int&gt; triplet(3, 0); triplet[0] = num[i]; triplet[1] = num[front]; triplet[2] = num[back]; res.push_back(triplet); while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++; while (front &lt; back &amp;&amp; num[back] == triplet[2]) back--; } } while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) i++; } return res; }}; 16. 3Sum ClosestMedium Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 分析： 整体思路同样类似于上面那题 mySolution: 12345678910111213141516171819202122232425262728293031323334class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { int result = -2000000000; //返回保存结果 sort(nums.begin(),nums.end()); // 排序 for(int i = 0;i &lt; (nums.size()-2);i++) { int low_margin = i + 1; int high_margin = nums.size() - 1; for(low_margin = i + 1 ; low_margin != high_margin ;) //遍历过程 { int temp = (nums[i] + nums[low_margin] + nums[high_margin]); int distance = abs(result - target); if (temp == target) { return target; } else if (temp &gt; target) { if ((temp - target) &lt; distance) { result = temp; } --high_margin; } else if (temp &lt; target) { if ((target - temp) &lt; distance) { result = temp; } ++low_margin; } } } return result; }}; 17. Letter Combinations of a Phone NumberMedium Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: 12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 分析： 这题主要就是如何完成笛卡尔积，当然 python 很好完成 在 c++ 中笛卡尔积可以用递归，或者我这种方法。就是将大小提取出来，然后写循环。 mySolution 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { const vector&lt;string&gt; number_letter{&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;}; //声明一个包含规则的 vector vector&lt;string&gt; temp_number_letter; //存储需要使用到的 vector int total_size = 1; //存储笛卡尔积的 size 大小 vector&lt;string&gt; result; if(digits.empty()) { return result; } for(auto i:digits) { temp_number_letter.push_back(number_letter[ (i - '0') - 2]); } for(auto i:temp_number_letter) { total_size *= i.size(); } for( int i = 0 ; i &lt; total_size ; ++i ) { string loop_temp; int m = 0,n = i; for(auto r_iter : temp_number_letter) { //n = n % temp_number_letter[r_iter].size(); //loop_temp += temp_number_letter[r_iter][n]; m = n % r_iter.size(); n = n / r_iter.size(); loop_temp += r_iter[m]; } result.push_back((loop_temp)); } sort(result.begin(),result.end()); return result; }}; 18. 4SumMedium Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 分析： 我个人的想法就是将其转换成子问题 子问题就是 3sum，然后就可以完成了。 mySolution: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class Solution {private: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; num,int target) { // 提供给下面 fourSum 的接口 vector&lt;vector&lt;int&gt; &gt; result; // 返回的值 //vector&lt;int&gt; temp; // 作为中间值添加进结果 //std::sort(num.begin(), num.end()); //将传进来的值排序 for(unsigned int i = 0 ; i &lt; num.size() - 2 ; ++i) { unsigned int num_media = i + 1; // 中间的那个值 unsigned int num_right = num.size() - 1; // 右边的那个值 if(( num[i] + num[i+1] + num[i+2]) &gt; target) { break; } if(( num[i] + num[num_right - 1] + num[num_right]) &lt; target) { continue; } for( num_media = i + 1 ;num_media &lt; num_right; ) { int temp = num[i] + num[num_media] + num[num_right] ; if( temp &lt; target ) { ++num_media; } else if ( temp == target ) { result.push_back({num[i],num[num_media],num[num_right]}); ++num_media; --num_right; } else if( temp &gt; target ) { --num_right; } } } return result; }public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt; &gt; result; //返回值 if(nums.size() &lt; 4) { return result; } std::sort(nums.begin(), nums.end()); //排序 for( unsigned int i = 0; i &lt; (nums.size() - 3) ; ++i) { int threeSum_target = target - nums[i]; vector&lt;vector&lt;int&gt;&gt; threeSum_result; vector&lt;int&gt; threeSum_num(nums.begin() + i + 1, nums.end()); if(( nums[i] + nums[i+1] + nums[i+2] + nums[i+3]) &gt; target) { break; } if(( nums[i] + nums[nums.size() - 3] + nums[nums.size() - 2] + nums[nums.size() - 1]) &lt; target) { continue; } threeSum_result = threeSum(threeSum_num, threeSum_target); for(auto num:threeSum_result) { vector&lt;int&gt; temp; temp.push_back( nums[i] ); temp.insert(temp.end(),num.begin(),num.end()); if( find(result.begin(),result.end(),temp) != result.end() ) { continue; } else { result.push_back(temp); } } } return result; }}; 19. Remove Nth Node From End of ListMedium Given a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? 分析： 比较正常的链表题 mySolution: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* temp = head; int length = 1; if(head == NULL) { return NULL; } while(temp-&gt;next != NULL) { temp = temp-&gt;next; ++length; } if(length == 1 &amp;&amp; n == 1) { return NULL; } if(length == n) { head = head-&gt;next; return head; } length = length - 1 - n; temp = head; while(length != 0) { temp = temp-&gt;next; --length; } ListNode* del_node = temp-&gt;next; temp-&gt;next = temp-&gt;next-&gt;next; delete del_node; return head; }}; 20. Valid ParenthesesEasy Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: 12Input: &quot;()&quot;Output: true Example 2: 12Input: &quot;()[]{}&quot;Output: true Example 3: 12Input: &quot;(]&quot;Output: false Example 4: 12Input: &quot;([)]&quot;Output: false Example 5: 12Input: &quot;{[]}&quot;Output: true 分析： 如果学习过编译原理，很好理解，利用栈的语法判断 mySolution: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution {public: bool isValid(string s) { vector&lt;char&gt; stack; for(auto i : s) { if(i == '(' || i == '{' || i == '[') { stack.push_back(i); } else if(i == ')') { if(stack.empty()) { return false; } else if(stack.back() == '(') { stack.pop_back(); } else { return false; } } else if(i == '}') { if(stack.empty()) { return false; } else if(stack.back() == '{') { stack.pop_back(); } else { return false; } } else if(i == ']') { if(stack.empty()) { return false; } else if(stack.back() == '[') { stack.pop_back(); } else { return false; } } } if(stack.empty()) { return true; } else { return false; } }}; 21. Merge Two Sorted ListsEasy Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 分析： 常规的链表题 mySolution: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* l1_temp = l1; ListNode* l2_temp = l2; ListNode* head = new ListNode(0); ListNode* head_temp = head; while(l1_temp != NULL &amp;&amp; l2_temp != NULL) { if(l1_temp-&gt;val &gt; l2_temp-&gt;val) { head_temp-&gt;next = l2_temp; head_temp = head_temp-&gt;next; l2_temp = l2_temp-&gt;next; } else if(l1_temp-&gt;val == l2_temp-&gt;val) { head_temp-&gt;next = l1_temp; head_temp = head_temp-&gt;next; l1_temp = l1_temp-&gt;next; head_temp-&gt;next = l2_temp; head_temp = head_temp-&gt;next; l2_temp = l2_temp-&gt;next; } else if(l1_temp-&gt;val &lt; l2_temp-&gt;val) { head_temp-&gt;next = l1_temp; l1_temp = l1_temp-&gt;next; head_temp = head_temp-&gt;next; } } while(l1_temp != NULL) { head_temp-&gt;next = l1_temp; head_temp = head_temp-&gt;next; l1_temp = l1_temp-&gt;next; } while(l2_temp != NULL) { head_temp-&gt;next = l2_temp; head_temp = head_temp-&gt;next; l2_temp = l2_temp-&gt;next; } return head-&gt;next; }}; 22. Generate ParenthesesMedium Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 分析： 这题是一道非常好的训练递归思想的题目。 我们确立是递归类型的问题 我们寻找递归的规律，我们发现整体思路，就是要想是合法的就得一直确保插入过程当中剩下的左括号的数量不能多于右括号（想不明白，可以自己仔细思考一下），所以就写出了以下程序。 mySolution: 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;string&gt; result; if (n &lt;= 0) { return result; } recursive_func(n,n,&quot;&quot;,result); return result; } void recursive_func(int left_num , int right_num , string temp , vector&lt;string&gt; &amp;result) { if( left_num == 0 &amp;&amp; right_num == 0) { result.push_back(temp); return ; } if( left_num &gt; 0) { recursive_func( left_num-1 , right_num , temp+&quot;(&quot; ,result); } if( left_num &lt; right_num) { recursive_func( left_num , right_num-1 , temp+&quot;)&quot; ,result); } }}; 28. Implement strStr()Easy Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: 12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 Example 2: 12Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). 个人分析： 模拟strstr() 函数 我个人的想法可能就是寻找第一个字符匹配的位置，匹配后面。 !KMP算法 mySolution: 1234567891011121314151617181920212223242526272829class Solution {public: int strStr(string haystack, string needle) { int i = 0,j = 0; if(needle.empty()) { return 0; } if((needle.size() &gt; haystack.size()) || haystack.empty()) { return -1; } for(i = 0;i &lt; haystack.size();i++) { int temp = i ; int temp_j = j; while (haystack[temp] == needle[temp_j]) { if(temp_j == needle.size() - 1) { return i; } temp++; temp_j++; } } return -1; }};","link":"/2020/07/07/leetcode_recode/"},{"title":"PETS 论文架构分析","text":"PETS 期刊的一些要求 Privacy Enhancing Technologies Symposium 不超过12页内容，不包括参考论文和附录内容（不限制页数） 整体架构 Abstract/Keywords（20-25行、4-6个） Introduction（1页半） Notation &amp; Background（1页） Related work（1页） 主要内容（3页） Experimental setup（1页半） Empirical results（2页半） Discussion and Future work（1页） Conclusion（15-20行） References（40-50个吧） 附录（A、B、C、D、E）","link":"/2022/02/07/pets%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"title":"LaTex技巧备忘","text":"对于 latex 相关的一些记录 LaTex技巧 文档类型（文章、报告、幻灯片）、宏包（\\usepackage{}）、模版 代码结构 123456789\\documentclass[]{}...... % 前导代码（preamble）\\begin{document}...... % 主体代码（body）\\end{document} \\part{}命令创建不同篇、使用\\chapter{}命令创建不同章、使用\\section{}命令创建一级节、使用\\subsection{}命令创建二级节、以及使用\\subsubsection{}命令创建三级节 \\uline可以增加单下划线，使用\\uuline可以增加双下划线，而使用\\uwave则可以增加波浪线，soul中的\\st命令生成删除线 反斜杠 (backslash) 符号使用\\textbackslash 如果我们想插入行内公式，可以直接在两个美元符号中间编辑需要的公式。如果想用美元符号插入行间公式，我们需要输入四个美元符号，与此同时，在四个美元符号中间编辑需要的公式。需要注意的是，这里生成的数学公式会自动居中对齐。 begin{equation}\\end{equation}，使用数学公式环境\\begin{equation} \\end{equation}， LaTeX编译时会自动将公式进行居中对齐。使用\\begin{equation*} \\end{equation*}就可以移除公式编号。 \\begin{align} \\end{align}，它主要用于数组型的数学表达式，align环境可以将公式进行自动对齐，它也能对每一条数学表达式分别进行公式编号。 \\begin{gather} \\end{gather}，它既可以将公式进行居中对齐，也能对每一条数学表达式分别进行公式编号 \\times，对应于符号×，\\cdot，对应于符号⋅，除法符号的命令为\\div ∩（\\cap）、∪（\\cup）、⊃（\\supset）、⊂（\\subset）、⊇（\\supseteq）、∈（\\in） 极限 $\\lim_{x\\to 2}x^{2}$，积分 \\int_{a}^{b}f(x),\\mathrm{d}x \\begin{array} \\end{array}环境来书写矩阵 LaTeX提供了多种表格环境用于制作各类表格，例如，tabular、tabular*、tabularx、tabulary、table和longtable等 12345678910111213141516\\begin{table} \\centering \\caption{Example of ABC} \\begin{tabular}{|c|c|c|c|} \\hline Column1 &amp; Column2 &amp; Column3 &amp; Column4\\\\ \\hline A1 &amp; A2 &amp; A3 &amp; A4\\\\ \\hline B1 &amp; B2 &amp; B3 &amp; B4\\\\ \\hline C1 &amp; C2 &amp; C3 &amp; C4\\\\ \\hline \\end{tabular} \\label{table1}% 索引标签\\end{table} LaTeX主要有两种管理参考文献的方法，第一种方法是在.tex文档中嵌入参考文献，参考文献格式需符合特定的文献引用格式；另一种方法则是使用 BibTeX进行文献管理，文件的拓展名为.bib。其中，使用外部文件BibTeX管理文献更加便捷高效。 bibtex：article：对应着期刊或杂志上发表的论文，必须添加的信息有author（作者）、title（标题）、journal（期刊）、year（年份）、volume（卷），可供选择添加的信息包括number（期）、pages（页码）、month（月份）、doi（数字对象识别码）等。 book：对应着书籍，必须添加的信息有author/editor（作者或主编）、title（书名）、publisher（出版社）、year（年份），可供选择添加的信息包括volume/number（卷/期）、series（系列）、address（出版地址）、edition（版号）、month（月份）、url（网址）等。 inbook：书籍中的一部分或者某一章节，必须添加的信息有author/editor、title（标题）、chapter/pages（章节/页码）、publisher（出版社）、year（年份），其他可供选择添加的信息与book一致。 inproceedings：对应着会议论文，必须添加的信息有author（作者）、title（论文标题）、booktitle（论文集标题）、year（年份），可供选择添加的信息包括editor（版号）、volume/number（卷或期）、series（系列）、pages（页码）、address（地址）、month（月份）、organization（组织方）、publisher（出版社）等。 conference：对应着会议论文，与inproceedings用法一致。 mastersthesis和proceedings：分别对应着硕士学位论文和博士学位论文，必须添加的信息有author（作者）、title（标题）、school（学校或研究机构）、year（年份）。 在LaTeX中插入Python代码可以使用verbatim环境，即在\\begin{verbatim} \\end{verbatim}之间插入代码 在LaTeX中，为了便于创建算法伪代码，现有很多相关的宏包，例如algorithm和algorithmic，在前导代码中申明使用这些宏包便可使用相应的算法伪代码环境。宏包algorithm提供的算法伪代码环境为\\begin{algorithm} \\end{algorithm}和\\begin{algorithmic} \\end{algorithmic}。","link":"/2022/02/09/latex_%E6%8A%80%E5%B7%A7/"},{"title":"科研绘图","text":"科研绘图 论文里的图可以分为模型图与数据展示图 配色一般是淡蓝、淡红、淡黄、淡绿 ，有时会用紫色、灰色补充（紫色多用于模块，灰色多用于小区域或者大面积打底） 模型图 可以使用 PPT 来画（我也觉得不错、相反visio不是很好用） 色调不宜太深，给人舒服的感觉 前后颜色需要一致 PPT文件可以直接导出为PDF，使用软件裁剪后即可插入到论文中，这样插入到论文里的是矢量图 数据展示图 latex 中的 tizk 包 matplotlib AxGlyph","link":"/2022/02/13/%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE/"},{"title":"Pytorch 环境配置日记","text":"该死的环境配置 Pytorch 环境配置日记 最近弄到实验室的两块 A5000 环境，想着把环境配好做实验，结果配置过程中发现怎么这么多坑（晕了！！） 正常配置 CPU 的版本是非常简单的，通过清华源快速又稳定 然而我是没想到 GPU 版本配置，真是废了我半条命 遇到的问题 服务器是共用的，每个人有自己的环境，所以我刚上的时候，发现 cudatoolkit 是配置好的，而且是 11.7 版本 于是我直接修改代码，开始跑实验，在我 torch.cuda 一切正常的情况下，告诉我缺少 lib 文件。于是我便寻找这个 lib 文件，确实找到了并添加环境变量，结果没用，依然报错！ 于是我想着那我自己重新配一个 cudatoolkit 环境，且我在 conda 过程中看到了那个 lib 。我开始重新配置，因为我上来就使用的是清华源，所以官网的 conda 命令无法使用，我想着应该无所谓，总有替换的命令 结果清华源一直报错，访问不了。这直接给我头整大了，我想着国内源也能访问不了，于是一通改配置文件，还是不行甚至卡。很久以后我把 我把 https -&gt; http 就正常了。。。 我想着这下 OK 了，下载过程中也确实 OK 了，结果我发现清华源的 cudatoolkit 版本没有 11.7，导致我 torch.cuda.is_avaiable() 一直 false，到底是不是版本问题待确定。于是我在 cuda 官网下了一个源文件，结果本地没有 sudo 权限，一时半会还给不了 最后我还是把 condarc 修改成原始配置，删除掉了清华源，看看最后结果如何 过了一晚，果然断了！外网是这样的，于是我想着就下老版本就可以吧，清华源不知道为什么没有跟进新版本，整个 torch 套装都落后好几个版本。老版本下载还算顺利 结果提醒一直没有 CUDNN 环境，于是我立马想到是不是和系统带的冲突了，因为我 CUDNN 下载的适配 CUDA11.3 而不是 CUDA11.7。于是我开始更换整个套装 torch、torchvision、CUDA、cuDNN ，直接从网站上下载然后 SCP 进去。结果这次提醒我，CUDNN 申请不到资源，我真是傻了。于是我找了同门，让他在那边实验，结果他环境也有问题，后来弄好了和我说他也申请不到。 原来是同门在上面跑巨大模型，又过了一天，终于成功跑起了我的代码，真是坎坷 总结 国内源不是无脑上的，需要具体问题解决，上网问题真是难呀","link":"/2022/02/15/pytorch%E4%B8%8B%E8%BD%BD%E6%97%A5%E8%AE%B0/"},{"title":"Pate_alibi 代码阅读记录","text":"Pate_alibi 代码阅读记录 文件夹目录如下├── CONTRIBUTING.md├── LICENSE├── README.md├── aggregate_votes.py├── cifar10│ └── cifar10├── lib│ ├── init.py│ ├── pycache│ ├── dataset│ ├── fixmatch.py│ ├── models│ └── pate├── memorization_attack│ ├── attack.py│ ├── confs│ └── confs_10x100├── pate│ ├── teacher_0.ckp│ └── teacher_0.ckp_ema├── requirements.txt├── train_cifar_alibi.py├── train_student.py└── train_teacher.py 整个代码贯穿着 logging 模块，很有利于调试，是很不错的习惯 使用 simple_parsing 处理命令行参数（对于后续实验调整参数非常方便） 整体代码架构也很清晰，将 setting 独立出来","link":"/2023/02/20/Pate_alibi%20%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"},{"title":"国重组会记录","text":"项目组会的小记录 组会记录 课题验收（2025年11月后3个月）、项目验收（现场演示）。打分制、财务、测评机构、论文相关性、标准。1年半系统要有相应的应用。 第一周 阿里沟通 各个系统之间的关系 项目课题的表 项目实施方案： 任务分工及接口关系需要修改（项目级的、课题级别的），接口之间需要更加细节（事前、事中、事后） 里程碑重新规划 技术实施路线（催各单位进行更新） 知识图谱（我来负责），要素驱动图谱、模型清晰然后制定知识图谱计划 量化 -&gt; 知识图谱生成 -&gt; 预警报告生成（给课题二） 模型建立（评估要素）、业务流程（知识图谱驱动）、量化评估（专家） 明确知识图谱的具体输入、输出，根据业务流程，能不能量化到什么程度 调研、技术方案制定 现存问题 业务流程不清晰 数据缺失 每个环节 服务驱动、场景关联 大数据平台与场景业务关联性 知识图谱实体构建思路","link":"/2022/03/01/%E5%9B%BD%E9%87%8D%E7%A0%94%E5%8F%91%E8%AE%A1%E5%88%92%E7%BB%84%E4%BC%9A/"},{"title":"生成式深度学习","text":"对于生成式模型的记录 生成式深度学习 记录学习书籍《生成式深度学习》 生成模型从概率模型的角度描述了生成数据集的方法。 图像生成问题中，特征通常就是每个像素的值。 模型生成成功条件： 该模型生成的采样看上去好像是从原数据集提取的结果 该模型生成的采样于是简单复制已有的数据点 参数化建模-&gt;似然估计-&gt;最大似然估计 深度学习如何处理特征之间的高度条件依赖、如何在高维样本空间中找到令人满意的数据 表示学习核心思想，不直接对高维样本空间建模，而是通过低维隐空间来描述训练集的每个预测，然后学习一个映射函数，将隐空间映射到原始域。隐空间中的每个点都是某个高维图像的表示 结构化数据例如表格、非结构化数据例如图像、视频 VAE 将高维输入数据压缩成低维表征向量的编码器以及通过解压将给定的表征向量还原到原始域的解码器神经网络 自动编码器中每个图像都直接映射成隐空间的一点，变分自动编码器每个图像都映射成隐空间中围绕某个点的多元正态分布 VAE 隐空间是一个连续的空间 上采样+Conv2D以及Conv2DTranspose 区别在于上采样不会用零填充像素之间的间隙 GAN 面临损失震荡（收敛不稳定）、模式收缩（输出单一化）、不提供信息的损失函数（判别器不断进化，损失函数不能横向对比） WGAN（Wasseerstein）优化过程的稳定性、与生成器的熟练度和样本质量相关的有意义的损失度量。修改损失函数 GAN 中有一点很重要，不要让判别器过强，以免梯度消失。如何平衡判别器与生成器的训练很关键。WGAN一般生成器两次更新之间训练5次判别器 WGAN-GP 修改了损失函数，不裁剪评论者的权重","link":"/2022/03/07/%E7%94%9F%E6%88%90%E5%BC%8F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"title":"DP 学习总结","text":"DP 相关的一些学习 DP 研究方向 建立 DP 基础隐私框架 提升 privacy/utility trade-offs 隐私保护攻击与审计 DP 隐私保护范围 DP 目前为了弥合 privacy/utility trade-offs 使用公共数据 设计数据自适应算法 设计个性化的 DP 算法 设计专门为使用 DP 进行学习而定制的 ML pipelines 部署 DP 防护的挑战 理解问题：明确自己的隐私需求 隐私方法对比：证明对于 DP 的需求 威胁模型：仔细建模信任假设 噪声影响 控制计算成本 如何满足数据分析 针对公共数据的思考 使用公共数据时需要哪些安全保护措施 互联网上的任何可用数据都是公开的吗 应考虑哪些隐私单元并为其设计隐私保护基础方法 公共数据集可能是未标记或标记的、小的或大的、分布内或分布外（相对于私有数据集） 使用公共数据的方式 公共预训练和私人微调 公共数据辅助私人训练（梯度、超参数选择） 私有查询发布中的公共数据 部分公开数据：想象数据的某些方面是公开的，而其他方面是私有的 公共数据的陷阱 DP 数据自适应方法 平滑灵敏度 PTR(propose-test-release)框架 PTR 变体 Data adaptive DP算法 统计估计 DP 在攻击方面局限性 DP 边界可能不会告知利益相关者感兴趣的系统最初容易受到针对数据隐私的具体攻击的程度：这可能使得在部署 DP 算法之前和之后评估隐私风险变得困难 由于边界与对手的能力无关，因此在某些情况下它可能过于保守或不准确 这种基于攻击的评估或审计提供的结果是对理论 DP 保证的补充 当前 DP 主要是针对数据匿名性 鲁棒性与隐私性的联系、 当基于差异隐私数据摘要做出决策时，代表性不足的群体可能会遭受更大的效用损失 差分隐私文献都假设每个用户向数据集贡献一个数据点 公共数据也可以用于超参数选择的重要任务、只有标签是敏感的，而特征向量不被认为是私有的 如何从第三方检测使用了正确的DP machine unlearning 对于隐私的影响","link":"/2022/04/26/DP%E5%AD%A6%E4%B9%A0/"},{"title":"数据蒸馏综述阅读","text":"数据蒸馏框架图 A Survey on Dataset Distillation: Approaches, Applications and Future Directions","link":"/2023/05/09/%E6%95%B0%E6%8D%AE%E8%92%B8%E9%A6%8F%E7%BB%BC%E8%BF%B0%E9%98%85%E8%AF%BB/"},{"title":"大佬工作总结","text":"整理一下赵佬的相关工作 目前身边学术做的非常好的同学的工作总结（进行参考） 他本身是做联邦学习安全加固（同态加密） 第一篇将基础的同态加密算法融合了 CNN 上的一些小 tricks。类比于我自己的方向来说，依然是可以使用常规的一些 DP 方案，加一些小的对于架构的处理。 第二篇、第三篇、第四篇除去本身同态加密方案上的更新，同时在场景上有所变换，包括实现去中心化的FL、垂直联邦的 FL、SGBoost、线性回归。","link":"/2023/05/10/%E5%A4%A7%E4%BD%AC%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"},{"title":"知识图谱构建学习记录","text":"现有国重项目对于知识图谱进行了解学习 知识图谱构建学习记录 主要学习《阿里云天池大赛赛题解析-深度学习篇》，赛题一——瑞金医院 MMC 人工智能辅助构建知识图谱 赛题解读 人工辅助糖尿病知识图谱构建，通过与糖尿病相关的指南与共识、研究论文等进行糖尿病文献挖掘，并构建糖尿病知识图谱 初赛——实体识别（15 类） 复赛——关系构建（10 类） 知识图谱核心就是构建描述的 SPO 三元组（subject、predicate、object），主要任务如下 识别主体与客体的实体识别（解决 S 与 O 的识别问题） 抽取实体对关系的预测（解决 P 的识别问题） 对多个知识图谱的实体进行对齐的知识融合（解决不同知识图谱的三元组队去） 理解句子中实体背后语义关系的指代消解（解决 S 与 O 的语义关系问题） 数据处理 常用的词向量表示：词向量（稀疏编码不能反映语义信息，占用空间大）与分布表示（稠密向量需要语言模型进行学习） 传统语言模型：词带模型（原句子顺序无关，只与字词出现的频率有关，TF-IDF 模型），n-gram 模型（极大似然估计，马尔可夫假设，词带是1-gram）。传统语言模型是通过计算句子序列的联合概率，不需要词向量。 神经语言模型，通常称为词嵌入模型。自编码器、无监督方式，隐层特征就是我们希望得到的词向量 .txt 文件由无分段的多行文本组成，主要难点在于句子的划分方式 实体识别 BIOES 标注（Begin、Intermedia、Other、End、Single）方法 有向图（贝叶斯网络） 无向图（马尔可夫随机场）、无向图模型的联合概率分布定义为归一化的最大团团势能之积，最大难点在于归一化函数的计算 隐马尔可夫模型（HMM）生成式有向图模型，常用于分词任务，表达能力有限 最大熵马尔可夫模型，判别式有向图模型，存在标注偏置的问题，每次状态转移倾向于选择更少转移的状态 条件随机场模型，判别式无向图模型 双向循环神经网络（BiRNN，包括BiLSTM、BiGRU），存在会出现 B——B 的形式，因为模型预测前后两个标注是独立的 BiLSTM 与 CRF 结合可以有效解决相关问题 总结","link":"/2023/05/04/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"评审工作记录","text":"第一次认真写一篇论文评审，做一次小记录 Summary Of The Paper: 这篇文章提出了一个 Lipschitz 约束的 VAE 变体用于实现差分隐私保证的数据合成方案。现有的主流数据合成方案是基于 DP-SGD 以及 PATE 框架结合 GAN、VAE、Diffusion Model等生成模型。本文章主要贡献点是针对常规 DP 添加噪声影响模型精度以及隐私预算有限问题，提出利用Lipschitz 约束实现独立于训练样本数量的差分隐私保证方法。 Main Review: Strength of the paper: 证明过程清晰 针对 VAE的无噪声 DP 有一定创新性,Lipschitz 结合 DP工作不是一个很新的概念，应用到 VAE 中目前我个人没见过 Weakness of the paper: 实验完备性不足： a) 数据质量没有实验数据：对于数据合成方案上，文章中强调不仅隐私保护效果更好，且数据质量更佳。在数据质量上并没有实验支撑，例如下游任务的精度，原数据集相似度等指标。 b) 对比方案不足：没有对比例如 DP-GAN、PATE-GAN、G-PATE、DataLens以及DP-Diffusion model等一系列其他数据合成主流方案 c) 数据集支撑不足：仅仅只对 mnist 数据集进行了实验，应该多扩展一些常见数据集 文中描述方案隐私保护效果对比 VAE-DPSGD，然而由实验图中可知，对于 MIA（成员推理攻击） 的保护效果并没有 VAE-DPSGD 好，且没有数据质量的实验数据前提下，方案优势并不明显。 所选 Lipschitz 常数与隐私保证之间的联系需要量化 文中写作错误","link":"/2023/05/12/%E8%AF%84%E5%AE%A1%E5%B7%A5%E4%BD%9C/"},{"title":"两人制裁判法","text":"裁判法记录 两人制裁判法学习记录 裁判员应该检查记录员填好的记录表，并确保再比赛开始前10分钟双方教练得记录表签名，指明首发，然后返回在记录台对面的位置。 赛前6分钟进行比赛介绍，比赛3分钟进行提醒，运动员最后热身。比赛开始前2分钟，两位裁判员移动到记录台，开始前1分30秒，鸣哨停止练习。 副裁判需要核实跳球是否合法。 追踪主要责任 24秒违例一律追踪吹 干扰球 篮板球，特别是越过后背抢球的情况 走步 制裁原则 不断的移动 监控，把所有队员都至于两裁判员之间 注意插进 寻找两队员之间的空间 前导裁判应该位于比赛的前方，尽可能快的跑到前方 前导主要职责 中锋策应或中锋位置的攻防 球篮下面的比赛 场上前导裁判一侧的持球突破 如果有3名或更多的防守队员在对方的后场，前导裁判不要急着跑向端线 正常情况下，每一次犯规后两裁判员需要转换位置。但是前导吹进攻犯规、追踪吹防守犯规不换 罚球时，追踪注意罚球的人和对面的人。前导注意对面的人。 由于与行为有关而警告队员或教练员时，不要停止比赛。如果警告是必须的，在比赛计时钟停止或球成死球时提出。如果有必要中断比赛，必须宣判技术犯规。","link":"/2023/05/16/%E8%A3%81%E5%88%A4%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"三人制裁判法","text":"三人裁判法记录 三人制裁判法学习记录 预测场上将要发生什么、理解场上正在发生什么、恰当反应已经发生什么 cc(主裁判)、u1(第一副裁判)、u2(第二副裁判) 开场的时候：主裁判负责从面对记录台的位置跳球抛球，U1站在记录台侧靠近中场位置的边线，U2站在对侧的球队席界线的位置 主裁判执行抛球，U1位于靠近中线的位置观察可能存在的抛球失误或跳球队员违例，U2位于场地对侧观察非跳球队员可能出现的违例。 每节的掷球入界总是由主裁判执行，U1、U2 根据前导和中央的位置 前导裁判，呈45度站位，不应该远离端线超过1米，并且应当在油漆区外侧，移动范围在三分线到限制区之间 中央裁判，任何弱侧朝向球篮的动作都属于中央裁判 三人制制裁运用成功与否，主要取决于前导和追踪裁判能够负责多少球侧的比赛情况 轮转的步骤 球位于靠近中场的位置 -&gt; 前导裁判位于 close down 球移动到弱侧 -&gt; a)前导裁判轮转到弱侧b)追踪裁判变成新的中央 前导裁判已经完成轮转→中央裁判变成新的追踪裁判，轮转完成 当弱侧有快速投篮和运球切入时，前导裁判不需要发动轮转 当前导发动轮转，快速移动不要跑。这使他可以在弱侧迅速投篮的情况下终止轮转，或对迎面而来的比赛做出判罚 当球运行到弱侧时，前导裁判要迅速判断是否可能发生快速投篮或运球突破。这种呼吸间的延误称为停留。如果弱侧队员快速投篮或运球突破，此时不要发动轮转，由中央裁判对弱侧有球区域观察。 当前导裁判完成轮转后，中央裁判是3人中最后落位的。当中央裁判移动到追踪的位置时，他应当使用后撤步，后退的同时始终面向篮筐 前导裁判应当以直线进行跑动，而不是曲线 当掷球入界恢复比赛时，掷球入界一侧总有两名裁判员 当掷球入界位于前场端线的三分线与篮板外缘之间时，前导裁判站在掷球入界点的外侧（中央裁判必须做好监控弱侧区域的准备，追踪裁判做出开表手势明示记录台）。当掷球入界位于前场端线的三分线与边线之间时，前导裁判站在掷球入界点和篮板之间。追踪裁判做出开表手势明示记录台。 暂停：在记录台人员将请求暂停的请求告知裁判后，通常由最靠近记录台的追踪裁判或中央裁判做出暂停信号。 （球队有机会选择在前场发球）在第四节或决胜期中，计时钟显示2:00或更少时，从后场掷球入界的球队请求了暂停 当一次犯规在后场被吹罚或者在前场出现进攻犯规时，裁判员将不进行换位","link":"/2023/05/23/%E4%B8%89%E4%BA%BA%E8%A3%81%E5%88%A4%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%20/"},{"title":"个人执裁技术","text":"个人制裁技术记录 个人执裁技术 距离和静立占位：保持开角并保持静立占位。不要太靠近队员，以缩小你的视野。 执裁防守：执裁有球情况时最重要的是注意观察防守队员的动作合法性，同时视野不离持球的进攻队员。 动态思维：积极寻找非法行为来鸣哨 45度和开角 注意力保持在一对矛盾上，直到他结束 进行抛球时，口中不要含哨。吹完哨，也把哨子吐出来 确保由于跳球违例而导致的任何掷球入界都在靠近中线的新前场执行 观察投篮，按照1-2-3原则：1.手 2.身体 3.脚（落地） 在前场端线发球时，执行裁判在把球给球员发球之前要鸣哨。","link":"/2023/05/23/%E4%B8%AA%E4%BA%BA%E6%89%A7%E8%A3%81%E6%8A%80%E6%9C%AF%E8%A6%81%E6%B1%82/"},{"title":"学术定理性结论记录","text":"学术论文阅读结论记录 阅读论文过程中，别人的一些结论进行记录，在自己工作中进行引用 差分隐私 在NLP任务中 DP模型的accuracy非常高 鼓励了privacy在语言模型的应用 （与之相对的是CV中DP会产生非常大的accuracy恶化 比如cifar10目前DP限制下只有80%accuracy 而不考虑DP可以轻松95%；ImageNet当时最好的DP accuracy不到50%） 在语言模型上 模型越大性能会越好 比如GPT2中 从4亿参数到8亿参数性能提升很明显 也取得了很多SOTA（但是在CV和推荐系统中 很多时候更大的模型性能会很差 甚至接近random guess 比如CIFAR10的DP best accuracy此前是由四层CNN得到的 而非ResNet） 在多个任务上取得SOTA的超参数是一致的 都是clipping threshold要设置的足够小 并且learning rate需要大一些（此前所有文章都是一个任务调一个clipping threshold 费时费力 并没有出现过像这篇这样一个clipping threshold=0.1 贯穿所有任务表现还这么好） 1Li X, Tramer F, Liang P, et al. Large language models can be strong differentially private learners[J]. arXiv preprint arXiv:2110.05679, 2021. 成员推理攻击 数据增强仅用于提升准确性时，强度低，它无法实现对 MIA 的实质性保护 高强度的数据增强，例如裁剪图像的 90%，会降低准确性，但也会降低风险 流行的标签平滑机制通常会同时增加准确性与风险 准确率越高，风险越高 1When Does Data Augmentation Help With Membership Inference Attacks? 分布之外的数据更不容易被成员推理 影子模型与训练模型同构，更容易实现攻击 越大的模型越容易被攻击 模型优化器影响不是很大 影子模型采用同样的数据增强会实现更好的攻击效果 数据增强会使的同一个样本在数据集重复出现，会有影响 1Membership Inference Attacks From First principles 成员推理攻击在复杂的数据集上要有效得多（在复杂的数据上更容易过拟合）。模型反演、模型窃取则相反。 模型参数的白盒参数访问对于成员推理攻击没有帮助 1ML-DOCTOR- Holistic Risk Assessment of Inference Attacks Against Machine Learning Models 神经网络模型架构越深，并不更容易受到攻击 具有高维输出（许多类）的任务比具有低维输出的任务更容易受到MIA的影响 过拟合不是成员推理攻击的决定性因素 所有在可推广模型上的实现中等或高成功率的黑匣子 MIA 都需要了解目标样本的真实类别 可推广性模型上的 MIA，对在模型参数有很大影响的记录上，如异常点或分布点，表现会更好 模型泛化能力很大程度上取决于所使用的优化器和正则化方法 优化器的选择对具有强背景信息的黑箱对手的可推广模型的潜在鲁棒性几乎没有影响 对于可推广的模型，唯一显著的差异出现在正确分类的样本和错误分类样本中间，而不是成员与非成员 1SoK: Membership Inference is Harder Than Previously Thought 过拟合模型可以使用一些不典型方式来将该实例识别为训练集成员 MIA 攻击分为单次质询攻击（准确率、置信度、交叉熵、logits）与多次质询攻击(label only)。把成员推理攻击又称之为 metirc-based attack,很有意思的称呼，与我理解不谋而合。 模型对于训练数据周围的数据应该比测试数据周围的数据能够更正确分类 训练数据相较于测试数据距离分类边界应该远 模型应该会对训练数据的数据增强结果更加准确的分类 1MemGuard: Defending against Black-Box MembershipInference Attacks via Adversarial Examples 对于 MIA 攻击效果的评估，应该考虑低假阳率（FPR）前提下的真阳率（TPR），这才是合理的评估指标，平均指标没有任何意义。 对于样本的衡量，文章考虑了两个性质，一个是样本在模型中拟合的难易程度（通过loss可以判断，loss低代表容易拟合），二是样本对于模型的影响，通过对比有无该样本训练的模型对于样本的评估差别，如果没与差别代表样本对于模型影响不大，如果差别很大代表样本本身对模型影响很大。很多攻击只考虑了对于模型影响特别大的样本，而对于影响不大的样本它就没办法判断了。 通过引入 per-class hardness（用来衡量每个类训练的难易程度），没有有效提升低 FPR 下的攻击效果。 通过使用 per-example hardness（用来衡量每个样本训练的难易程度），有效提升低 FPR 下的攻击效果。 过拟合的模型更容易受到攻击，而且更准确的模型更容易受到攻击。 攻击模型与目标模型架构相同时，攻击效果最好，差别越小效果越好。 optimizer（SGD、SGDM、ADAM） 对于攻击效果没有影响。 如果影子模型数据增强方式与目标模型对应时，攻击效果最好。使用的数据增强越强，越难被攻击。 对于本攻击来说，白盒并没有什么改进。 1Membership Inference Attacks From First Principles 文章提出成员样本与非成员样本可能最终 loss 差别不大，但是 loss trajectory（loss下降曲线）是不一样的。 蒸馏数据集越大，代表攻击者有更多的辅助数据集，效提升低 FPR 下的攻击效果。 1Membership Inference Attacks by Exploiting Loss Trajectory 目标数据集中数据样本的分布对 FNR 的影响很小 训练集数据之间的距离越大，MA攻击概率越高 训练机数据之间的距离对 FNR 影响很小 两个数据集之间的差异越大，攻击成功率越高 两个数据集之间的差异距离对 MIA 的影响大于目标数据集数据间的距离 两个数据集之间的差异距离对 FNR 影响很小 1SoK: Comparing Different Membership Inference Attacks with a ComprehensiveBenchmark 文章提出了隐私洋葱理论，通过在特定的隐私攻击下删除最易受攻击的数据，并仅在以前安全的数据上重新训练模型，一组新的示例反过来也容易受到相同的隐私攻击 统计噪声、训练集大小的减少、重复训练示例的存在或模型的有限能力并不能解释洋葱效应。实验表明，洋葱效应可以用去除更极端的异常值后变为异常值的内部值来解释 工作表明，现有隐私审计缺乏“稳定性”，因为由于删除了一小部分训练数据，用户的经验隐私风险可能会发生显著变化。未来隐私审计应该随着底层数据变化而动态更新 也就是说 machine unlearning 会导致其他用户的隐私有更大的风险 1The Privacy Onion Effect: Memorization is Relative 神经网络训练 数据规模可以压制标签中存在的噪声 随着训练数据数量级的增加，任务性能呈对数上升 数据集是一个长尾分布（意思异常值与错误值以及非典型例子占大多数），而对于这些例子模型往往是采用记忆的方法也就是强行背下来的方法，但是这种记忆对于模型达到最优泛化能力是不可获取的 记忆得分高的例子是非典型例子和异常值/错误标记的例子的混合，经典例子的记忆得分往往更低 在受显著影响的测试示例中，大多数仅受单个训练示例的显著影响 互相高影响的数据对，在视觉上有很强的相似性 对于成员推理攻击的防御，减少记忆会影响模型的准确度 在CIFAR-100上删除这两组中的964个独特训练示例可将测试精度降低2.46±0.36%，这与删除11000个随机示例的效果相当 记忆并不是只存在于最后一层1What Neural Networks Memorize and Why:Discovering the Long Tail via Influence Estimation 针对同样的数据集，采样不同的数据子集，同样的任务，异常点是会改变得，正常点大致相同 异常值包含的规律很傻，很难提取出规律，所以一般模型会直接记忆 更难提取的规律同样会在蒸馏过程中消失，小模型不会记忆太多异常值 提供了一个思路：查看哪些神经元（权重值）与小样本有关，一个神经元（权重值）被很多不同的规律激活，代表就会对多个前向传播的信号有作用；一个神经元（权重值）被激活的很少，代表对异常值有作用1Extracting Training Data from Large Language Models 隐私数据合成 数据合成领域主要包括 表格数据（Tabular data）、轨迹数据（Trajectory data）、图数据（Graph data） 对于合成数据方法可以做的工作 隐私攻击：文章认为常见的成员推理攻击本身就是针对 logits 等信息，而在数据合成领域应该有更多的信息可以利用 隐私度量：这是隐私领域通用的一个难题，如何去提出一个通用型隐私量化标准 威胁模型：去研究是否有更合理的威胁模型假设，放宽隐私限制（类似于 label DP） 公平性问题研究：针对合成数据对于不具有代表性的分类可能会有公平性问题解决方案设计1SoK: Privacy-Preserving Data Synthesis 大模型 PII 隐私 训练数据中包含的不同类型的 PII 的很大一部分可以通过战略制作的提示披露 通过细化提示，可以访问模型参数，并为 LLM 利用几百个训练数据点，显著放大 PII 泄漏的程度1ProPILE: Probing Privacy Leakage in Large Language Models","link":"/2099/12/12/%E5%AD%A6%E6%9C%AF%E5%AE%9A%E7%90%86%E6%80%A7%E7%BB%93%E8%AE%BA%E8%AE%B0%E5%BD%95/"},{"title":"2080ti 服务器配置","text":"正值师兄毕业，给我传承了一个双卡 2080 ti 计算环境，也是第一次重新配置服务器，浅浅记录一下 2080ti 服务器配置 第一个问题：服务器放置环境问题解决 将服务器搬置了 403 密码实验室中，机柜环境都是现成的，省事儿了不少 第二个问题：网络配置（最少实现学校内网访问，其实也够了） 检查已有的交换机发现交换机本身没有连上学校网络，于是采用自己的路由器方式，直链学校网口，再通过端口映射进行访问。这里面就遇到了一个问题，链接上后一直 network 起不来，不知道为什么。经过一通配置发现原来是插的网口不对，换了个网口就好了。。。 第三个问题：ssh 能否连上 因为之前有人在用这个服务器，所以本质上 AI 环境以及 ssh 都是已经配置好的，只需要完成问题二则可以直接链接。ssh 刚开始一直连不上，本质上也是因为问题二没有解决，一直以为是 amax 的端口其实不是 第四个问题：没有图形化界面 刚开始启动后，屏幕没有任何反应，要么是图形化界面崩了，要么是显卡驱动有问题。威哥直接就说是图形化界面问题，一问师兄还真是。当时想着要么重新装，其实可以通过 ctrl + alt + F1 进入命令行界面，里面配置一些就没啥问题 所以其实本质上就是一个网络配置的问题，解决了以后就正常使用了。也是感谢几位哥们帮忙，从未接触过物理服务器环境，以前都是直接拿来用。这次对于物理服务器基本配置使用就有所了解，是一次学习经历","link":"/2023/06/08/2080ti%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"title":"数据安全法","text":"数据安全法的一些相关解读 数据安全法 数据，是指任何以电子或者其他方式对信息的记录 第二十一条规定了 数据分类分级保护制度 第二十二条规定了 数据安全风险评估、报告、信息共享、监测预警机制。加强数据安全风险信息的获取、分析、研判、预警工作 第二十三条规定了 数据安全应急处置机制 第二十四条规定了 数据安全审查制度 第三十条规定了 重要数据的处理者应当按照规定对其数据处理活动定期开展风险评估，报送风险评估报告 风险评估报告应该包括包括处理重要数据的种类、数量，开展数据处理活动的情况，面临的数据安全风险及其应对措施 第三十三条规定了 从事数据交易中介服务的机构提供服务，应当要求数据提供方说明数据来源 企业合规建议 按照《数据安全法》及其相关法律法规、监管要求，建立数据全生命周期合规管理制度与流程。 建立数据分级分类目录及重要数据目录 重要数据风险评估制度 建立自身的重要数据出境管理制度 数据出口管制制度的建立","link":"/2023/06/29/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%B3%95/"},{"title":"数据分类分级","text":"数据分类分级的浅了解 数据分类分级初了解《网络安全标准实践指南——数据分类分级》 数据分类分级原则 a) 合法合规原则：优先识别法律法规中规定的数据类别或级别，如识别是否包含国家核心数据、重要数据、个人信息、公共数据 b) 界限明确原则：数据分类分级的各类别、各级别界限明确 c) 就高从严原则 d) 时效性原则 d) 自主性原则 数据分类分级框架 个人信息分类 数据分类分级流程 论数据分类分级目的、原则与规划","link":"/2023/06/29/%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB%E5%88%86%E7%BA%A7%E5%88%9D%E4%BA%86%E8%A7%A3/"},{"title":"论文流程整理","text":"题目（Title），摘要（Abstract），前言（Introduction），方法（Methods），结果（Results），讨论（Discussion），致谢（Acknowledgments）（可选），参考文献（References），附录（Appendix） 论文流程 Title 尽量的短并且没有歧义，能够充分描述研究，包含描述研究的关键词，如果可能，加入研究的关键结果 题目尽量的早写，但是通常会在文章最终内容确定之后再进行修改 Abstract 研究背景(1-2句话) 问题（一句话）：一般以However开头 文章主旨（一句话）：一般以Here/Herein开头，一句话概括文章的主要内容。如Here, we show/report/demonstrate/present/introduce et al. 注意使用第一人称we。 实验方法及主要结论(各用一句话) 可以使用主动语态，但是主要使用被动语态 Index Terms Introduction 扩展说明一下研究的任务定义以及研究该任务的意义 目前的挑战是什么，举例说明（现存工作没有解决的问题） 阐述现存工作，有什么问题 a) 现在的工作是怎么做的，可以分为几大类，每一类有若干典型工作，阐述 b) 他们存在的缺点，任务挑战他们还没有很好解决 为了解决问题，提出了什么模型，包括几部分，可以展开介绍每个部分的功能和效果，用到的技术 本文的贡献：一般3点，注意重点突出模块的作用和效果 可以使用主动语态，第一人称不要过度使用就行 研究内容的时候，可以用过去时，也可以用一般现在时 写完前言之后，看它是否回答了下面问题：文章研究了什么？为什么这是个重要的问题？在我做研究之前我知道什么？这篇文章会如何使当前的研究前进？ 在写的时候，倒着去写引言部分，从具体的研究目的开始，再确定研究背景是什么，然后再到更一般的宏观信息 Preliminaries Related work1. 分成 2-3 部分说明2. 每一部分的相关工作可以按照类别展开说明3. 再具体每个工作的细节4. 最后说一下之前的工作和我们的区别，我们的优势在哪儿 方案1. 整体一段介绍模型的总体结构图2. 分段阐述每个模块（为了达到什么目的，用什么方法，怎么做） a) 先说目的和作用 b) 再说怎么个操作和过程 Evaluation 实验结果（分析为主，效果的提升不要重点说，为什么有提升，为什么效果不好，重点写） a) 主实验——表格双栏 b) ablation 实验 c) 分析实验，解释一下模型内部的机理或者为啥奏效 d) 可视化实验 e) 参数实验 conclusion 我们提出了什么（几个模块、模块的作用，达到的效果） 实验数据（实验结果说明了什么，直接给结论，不用再写分析之类的） 未来的工作 在写草稿的时候，在图表的下方标注该图表给出的一到两个关键的结果 Appendeix 注意事项 1.每天在时间表中安排1到2个小时 的时间块进行写作，无论什么原因都要完成。 2.挑选自己最高效 的时间进行写作，作者提出对大多数人来说，早晨效率更高 准备工作 列中心思想 写 Outline 初稿","link":"/2023/07/03/%E8%AE%BA%E6%96%87%E6%B5%81%E7%A8%8B%E6%95%B4%E7%90%86/"},{"title":"xgboost 学习","text":"xgboost 学习记录 xgboost 学习 主要学习方法B站UP-老弓的学习日记 问：为什么不用梯度下降算法而是用前向传导答：因为阶越函数有关，他是二分类，要么是1要么-1，所以没办法求导 问：为什么会有泰勒展开这一步答：因为损失函数是不确定的，但是我们又想找到共同之处。（GBDT-一阶展开，XGBOOST-二阶展开） 问：怎么分裂结点 问：怎么样算结束呢答： 问：有没有什么优化方法？答： shrinkage 是啥呢？答： 核外块运算答： 缓存优化答：","link":"/2023/07/07/xgboost%E5%AD%A6%E4%B9%A0/"},{"title":"Java 注意点记录","text":"学习 Java 的一些基础知识 Java 注意点记录 自动类型转化 boolean 占几个字节 Java 中 0.1+0.2 != 0.3 为啥呢 项目结构 break 和 continue Java 中内存区域是怎么划分的 一维数组内存 二维数组内存 时间复杂度 稳定性 排序算法复杂度 数组为什么要从 0 开始编号，而不是 1 类的内存存放 Java 的参数传递机制 Java的数据封装 JavaBean 成员变量与局部变量的区别 Super调用构造器 子类对象实例化对象 equals()使用 toString() 使用 接口和抽象类的区别","link":"/2023/07/20/Java%E6%B3%A8%E6%84%8F%E7%82%B9/"},{"title":"数据仓库建设记录","text":"现有数仓的一些框架架构 数据仓库 技术框架 系统架构框架","link":"/2023/07/25/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%E8%AE%B0%E5%BD%95/"},{"title":"leetcode 周赛","text":"leetcode 周赛的记录 leetcode_周赛第 360 周赛 2833.距离原点最远的点 思路：转换题目就是 L 与 R 的绝对值差值最大值，加上 _ 的数目 2834. 找出美丽数组的最小和 思路：这题可以使用数位 DP 去做，比赛时采用的是分类讨论也不是很复杂 123456789class Solution: def minimumPossibleSum(self, n: int, target: int) -&gt; int: if n &lt;= (target // 2): return sum(range(1,n+1)) else: temp = list(range(1,target//2 + 1)) for i in range(n-target//2): temp.append(target+i) return sum(temp) 2835. 使子序列的和等于目标的最少操作次数 思路：这题本身比赛时，思路是正确的，想到了使用二进制去解决这个题，包括用低位求和，高位去除等思路。卡在了一是没想清楚从低到高还是从高到低，二是如何低位求和时从数组中删除已经使用的元素。第一一定是从低到高，因为在遍历数组过程中，需要遍历的是求和的，高位不需要。二是使用 mask 位置来进行 &amp; 操作即可让 target-已经被求和的数 ，且使用 Counter 统计元素个数以及自动排序，确实是没想到。 12345678910111213141516171819202122class Solution: def minOperations(self, nums: List[int], target: int) -&gt; int: if sum(nums) &lt; target: return -1 cnt = Counter(nums) ans = s = i = 0 while 1 &lt;&lt; i &lt;= target: s += cnt[1 &lt;&lt; i] &lt;&lt; i mask = (1 &lt;&lt; (i + 1)) - 1 i += 1 if s &gt;= target &amp; mask: continue ans += 1 # 一定要找更大的数操作 while cnt[1 &lt;&lt; i] == 0: ans += 1 # 还没找到，继续找更大的数 i += 1 return ans作者：灵茶山艾府链接：https://leetcode.cn/problems/minimum-operations-to-form-subsequence-with-target-sum/solutions/2413344/tan-xin-by-endlesscheng-immn/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2836. 在传球游戏中最大化函数值 思路：当时想的首先就是确定起点与 K，最后的结果是固定的。所以想的是递归是否可行，仔细想了一下是不可以的，因为即使前面是最大的，你也没办法判断转移状态是否是最大得。爆破更是不可能的，因为 k 的范围非常大，起点范围也很大。所以没想清楚怎么做，看灵神提到了一个树上倍增的思想，我觉得有点类似快速幂的想法。将一个数拆成 2 的幂的和，用空间换取时间，使用二维数组进行存储。 12345678910111213141516171819202122232425 class Solution: def getMaxFunctionValue(self, receiver: List[int], k: int) -&gt; int: n = len(receiver) m = k.bit_length() - 1 pa = [[(p, p)] + [None] * m for p in receiver] for i in range(m): for x in range(n): p, s = pa[x][i] pp, ss = pa[p][i] pa[x][i + 1] = (pp, s + ss) # 合并节点值之和 ans = 0 for i in range(n): x = sum = i for j in range(m + 1): if (k &gt;&gt; j) &amp; 1: # k 的二进制从低到高第 j 位是 1 x, s = pa[x][j] sum += s ans = max(ans, sum) return ans作者：灵茶山艾府链接：https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/solutions/2413298/shu-shang-bei-zeng-by-endlesscheng-xvsv/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 第 361 周赛7020. 统计对称整数的数目 思路：这题当时因为给的范围特别小，我直接把所有的满足要求的数打印出来。灵神则是通过，遍历 Low High 直接对比两位。当时做这个题的时候，总觉得是有规律的，按道理应该是可以减少时间复杂度的。 12345678910111213class Solution: def countSymmetricIntegers(self, low: int, high: int) -&gt; int: ans = 0 for i in range(low, high + 1): s = str(i) n = len(s) ans += n % 2 == 0 and sum(map(int, s[:n // 2])) == sum(map(int, s[n // 2:])) return ans作者：灵茶山艾府链接：https://leetcode.cn/problems/count-symmetric-integers/solutions/2424088/mei-ju-by-endlesscheng-oo2d/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2844. 生成特殊数字的最少操作 思路：这题思路是很清晰的，保证最后两位是 00 25 50 75 即可，但是我在写的时候从右开始遍历的时候，是手写的逻辑，所以中间调试等走了一些弯度。灵神直接使用 rfind() 函数，只能说还是不了解，如果知道有这个函数，真的会省很多事儿。 123456789101112131415class Solution: def minimumOperations(self, num: str) -&gt; int: n = len(num) def f(tail: str) -&gt; int: i = num.rfind(tail[1]) if i &lt; 0: return n i = num.rfind(tail[0], 0, i) # 写成 num[:i].rfind(tail[0]) 会产生额外的切片空间 if i &lt; 0: return n return n - i - 2 return min(n - ('0' in num), f(&quot;00&quot;), f(&quot;25&quot;), f(&quot;50&quot;), f(&quot;75&quot;))作者：灵茶山艾府链接：https://leetcode.cn/problems/minimum-operations-to-make-a-special-number/solutions/2424068/mei-ju-shan-chu-hou-yi-00255075-jie-wei-zhjlu/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2845. 统计趣味子数组的数目 思路：首先得把题目进行一个转换，转换成子序列和，而这中间又涉及一个如何把（l,r）之间的和弄出来，这边灵神的思路是再保留一个 list，元素 i 就是子序列前 i 个元素的和，真的是非常妙呀！要擅长使用过 Counter() 代表哈希表 1234567891011121314class Solution: def countInterestingSubarrays(self, nums: List[int], mod: int, k: int) -&gt; int: cnt = Counter([0]) # 把 s[0]=0 算进去 ans = s = 0 for x in nums: s += x % mod == k ans += cnt[(s - k) % mod] # Python 取模可以把负数自动转成非负数 cnt[s % mod] += 1 return ans作者：灵茶山艾府链接：https://leetcode.cn/problems/count-of-interesting-subarrays/solutions/2424063/qian-zhui-he-ha-xi-biao-fu-ti-dan-by-end-74bb/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2846. 边权重均等查询 思路：超出能力范围，但是需要复习一些树相关的模版 第 363 周赛2848. 与车相交的点 思路：这题我做的时候的思路是通过维护一个状态 list，通过遍历来进行置 1，就是爆破的思路。而在灵神思路他提到了，差分数组这个思路，也就是说不用去遍历 start，end。而是只需要设置 start、end两个位置即可，节省了很多时间 12345678910111213class Solution: def numberOfPoints(self, nums: List[List[int]]) -&gt; int: max_end = max(end for _, end in nums) diff = [0] * (max_end + 2) for start, end in nums: diff[start] += 1 diff[end + 1] -= 1 return sum(s &gt; 0 for s in accumulate(diff))作者：灵茶山艾府链接：https://leetcode.cn/problems/points-that-intersect-with-cars/solutions/2435384/chai-fen-shu-zu-xian-xing-zuo-fa-by-endl-3xpm/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2849. 判断能都在给定的时间到达单元格 思路：这题本质上不是一个什么算法题，因为它是一个思路题，为啥好说的，和灵神代码一样 12345678910class Solution: def isReachableAtTime(self, sx: int, sy: int, fx: int, fy: int, t: int) -&gt; bool: if sx == fx and sy == fy: return t != 1 return max(abs(sx - fx), abs(sy - fy)) &lt;= t作者：灵茶山艾府链接：https://leetcode.cn/problems/determine-if-a-cell-is-reachable-at-a-given-time/solutions/2435321/xian-xie-zhao-zou-zai-zhi-zou-ran-hou-za-lkxu/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2850. 将石头分散到网格图的最少移动次数 思路：这题目在思考的时候，我思考是一个枚举的题目，但是没有想好如何去枚举，也没接触过全排列。这里可以使用 permutations() 函数. 1234567891011121314151617181920212223class Solution: def minimumMoves(self, grid: List[List[int]]) -&gt; int: from_ = [] to = [] for i, row in enumerate(grid): for j, cnt in enumerate(row): if cnt &gt; 1: from_.extend([(i, j)] * (cnt - 1)) elif cnt == 0: to.append((i, j)) ans = inf for from2 in permutations(from_): total = 0 for (x1, y1), (x2, y2) in zip(from2, to): total += abs(x1 - x2) + abs(y1 - y2) ans = min(ans, total) return ans作者：灵茶山艾府链接：https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/solutions/2435313/tong-yong-zuo-fa-zui-xiao-fei-yong-zui-d-iuw8/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2851. 字符串转换 思路：首先得想明白他的操作，她转换字符串其实就是循环右移字符串。接着想明白 DP 的状态转移方程，再去想如何取值，涉及到 KMP算法。而在 DP 过程中，可以使用快速幂加快时间。 123456789101112131415class Solution: def numberOfWays(self, s, t, k): n = len(s) c = self.kmp_search(s + s[:-1], t) m = [ [c - 1, c], [n - c, n - 1 - c] ] m = self.pow(m, k) return m[0][s != t]作者：灵茶山艾府链接：https://leetcode.cn/problems/string-transformation/solutions/2435348/kmp-ju-zhen-kuai-su-mi-you-hua-dp-by-end-vypf/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 第 364 周赛2864.最大二进制奇数 思路：这题目较为简单，就是找对思路，利用 count 计算0、1 个数，返回即可 2865.美丽塔 I 思路：这个题目，艾神强调了 leetcode 中计算次数大概在 10^6 10^7 附近，题目逻辑不是很复杂，我单独写了一个函数，计算假如把当前位置当峰顶，计算返回值多少。然后遍历数组，不是全遍历，遍历比前一个值大的位置，返回最大的即可。思路来说和艾神的暴力做法思路一致，但是在写法上艾神更加简洁。首先再次使用了 enumerate() 函数，这样就不用单独写一个函数逻辑，并设置更多的参数等。第二个逻辑没有他简洁，使用 min 维护一个变量便解决了问题，而不是我那样另设置一个数组。 123456for i in range(n-1,-1,-1): x = a[i]等价于for i,x in enumerate(a): 2866.美丽塔 II 思路：同样的题目，需要降低时间复杂度。其实我在自己写的时候已经体现出了栈的思想。使用单调栈，通过.pop 与 .append 来实现栈的弹入弹出。直接 1516ms 变成了 64ms 12345678910111213141516171819202122232425262728293031class Solution: def maximumSumOfHeights(self, a: List[int]) -&gt; int: n = len(a) suf = [0] * (n + 1) st = [n] # 哨兵 s = 0 for i in range(n - 1, -1, -1): x = a[i] while len(st) &gt; 1 and x &lt;= a[st[-1]]: j = st.pop() s -= a[j] * (st[-1] - j) # 撤销之前加到 s 中的 s += x * (st[-1] - i) # 从 i 到 st[-1]-1 都是 x suf[i] = s st.append(i) ans = s st = [-1] # 哨兵 pre = 0 for i, x in enumerate(a): while len(st) &gt; 1 and x &lt;= a[st[-1]]: j = st.pop() pre -= a[j] * (j - st[-1]) # 撤销之前加到 pre 中的 pre += x * (i - st[-1]) # 从 st[-1]+1 到 i 都是 x ans = max(ans, pre + suf[i + 1]) st.append(i) return ans作者：灵茶山艾府链接：https://leetcode.cn/circle/discuss/WhhMVw/view/h8u9cM/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2867.统计树中的合法路径数目 思路：题目我看都没看，树相关的算法主要抱着学习角度去看，其实就是图相关的算法很类似。学习到了判断质数的算法，需要注意的是从 i*i 开始，而不是 i，因为之前肯定遍历过了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 标记 10**5 以内的质数MX = 10 ** 5 + 1is_prime = [True] * MXis_prime[1] = Falsefor i in range(2, isqrt(MX) + 1): if is_prime[i]: for j in range(i * i, MX, i): is_prime[j] = Falseclass Solution: def countPaths(self, n: int, edges: List[List[int]]) -&gt; int: g = [[] for _ in range(n + 1)] for x, y in edges: g[x].append(y) g[y].append(x) def dfs(x: int, fa: int) -&gt; None: nodes.append(x) for y in g[x]: if y != fa and not is_prime[y]: dfs(y, x) ans = 0 size = [0] * (n + 1) for x in range(1, n + 1): if not is_prime[x]: # 跳过非质数 continue s = 0 for y in g[x]: # 质数 x 把这棵树分成了若干个连通块 if is_prime[y]: continue if size[y] == 0: # 尚未计算过 nodes = [] dfs(y, -1) # 遍历 y 所在连通块，在不经过质数的前提下，统计有多少个非质数 for z in nodes: size[z] = len(nodes) # 这 size[y] 个非质数与之前遍历到的 s 个非质数，两两之间的路径只包含质数 x ans += size[y] * s s += size[y] ans += s # 从 x 出发的路径 return ans作者：灵茶山艾府链接：https://leetcode.cn/circle/discuss/WhhMVw/view/h8u9cM/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 第 368 周赛2908、2909 元素和最小的山形三元组 思路：第一题和第二题知识数字范围不同，但是思路一样，我们遍历山峰，但是关键在于如何对于左右两边的值进行最小的取值，其实右边可以从右往左，用一个变量保留最小的数，左边同理。其次记住 inf 的使用 123456789101112131415class Solution: def minimumSum(self, nums: List[int]) -&gt; int: n = len(nums) suf = [0] * n suf[-1] = nums[-1] for i in range(n - 2, 1, -1): suf[i] = min(suf[i + 1], nums[i]) ans = inf pre = nums[0] for j in range(1, n - 1): if pre &lt; nums[j] &gt; suf[j + 1]: ans = min(ans, pre + nums[j] + suf[j + 1]) pre = min(pre, nums[j]) return ans if ans &lt; inf else -1 2910 合法分组的最少组数 思路：将这个问题转换成了一个数学问题，如下图所示，所以 leetcode 问题一定要先将他转换成数学问题 1234567891011121314151617class Solution: def minGroupsForValidAssignment(self, nums: List[int]) -&gt; int: cnt = Counter(nums) for k in range(min(cnt.values()), 0, -1): ans = 0 for c in cnt.values(): q, r = divmod(c, k) if q &lt; r: break ans += (c + k) // (k + 1) else: return ans作者：灵茶山艾府链接：https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/solutions/2493313/ben-ti-zui-jian-dan-xie-fa-pythonjavacgo-t174/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2911 得到 K 个半回文串的最少修改次数 思路：是一个划分型 DP 问题，如下图所示，需要先进行预处理对于判断字符串变成半回文字符串需要多少步形成一个函数。 123456789101112131415161718192021222324252627282930313233343536373839# 预处理每个数的真因子，时间复杂度 O(MX*logMX)MX = 201divisors = [[] for _ in range(MX)]for i in range(1, MX): for j in range(i * 2, MX, i): divisors[j].append(i)def get_modify(s: str) -&gt; int: res = n = len(s) for d in divisors[n]: cnt = 0 for i0 in range(d): i, j = i0, n - d + i0 while i &lt; j: cnt += s[i] != s[j] i += d j -= d res = min(res, cnt) return resclass Solution: def minimumChanges(self, s: str, k: int) -&gt; int: n = len(s) modify = [[0] * n for _ in range(n - 1)] for left in range(n - 1): for right in range(left + 1, n): # 半回文串长度至少为 2 modify[left][right] = get_modify(s[left: right + 1]) @cache def dfs(i: int, j: int) -&gt; int: if i == 0: return modify[0][j] return min(dfs(i - 1, L - 1) + modify[L][j] for L in range(i * 2, j)) return dfs(k - 1, n - 1)作者：灵茶山艾府链接：https://leetcode.cn/problems/minimum-changes-to-make-k-semi-palindromes/solutions/2493147/yu-chu-li-ji-yi-hua-sou-suo-by-endlessch-qp47/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2023/08/28/leetcode_%E5%91%A8%E8%B5%9B/"},{"title":"Docker 学习记录","text":"回顾 Docker 的一些知识 Docker 学习 问题一：为什么要有 Docker？答：DevOps，减少运维负担，降低环境配置成本。隔离是 Docker 的核心思想，可以充分利用服务器。 问题二：Docker 历史答：2010年，美国成立了一个公司 dotcloud，刚开始做 pass 的云计算服务， 他们将自己的容器技术命名为 Docker，2013 年并进行了开源。2014年4月9日，Docker 1.0 发布 问题三：Docker 和虚拟机区别答：容器化技术不是模拟一个完整的操作系统，容器是没有自己的内核得，也没有虚拟我们的硬件。虚拟机加载 Guest OS，分钟级别。docjer 利用宿主机操作系统。 Docker 常用命令12345678docker rmi -f $(docker images -aq) # 删除全部的容器docker ps -a 列出所有的正在运行的容器+带出历史运行过的容器docker inspect [container] 查看容器的元数据docker stats 查看 docker 内存状况 Docker 镜像加载原理 UnionFS 联合文件系统，一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加。从外面看来只能看到一个文件系统，联合家在会把各层文件系统叠加起来 很像拼积木 思想感觉就是能公用就公用 Docker 镜像都是只读的，当容器启东市，一个新的可写层被加载到镜像的顶部！这一层也就是容器层，容器之下都叫镜像层。 Docker 容器数据卷需求：数据可持久化容器持久化与同步，容器间可以数据共享 docker run -v 参数 数据卷容器 使用 --volume-from DockerFile 完整的一个构建 tomcat 镜像的 DockerFile 上传镜像到 DockerHub Docker 全流程 Docker 网络 自定义网络也很有意思，相当于自己写了个配置文件","link":"/2023/08/31/Docker%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"leetcode 模版","text":"编程常用模版 leetcode_模版KMP 模版(KMP算法是一种字符串匹配算法，可以在O(n+m) 的时间复杂度内实现两个字符串的匹配)12345678910111213141516171819202122232425262728293031323334# KMP 模板 def calc_max_match(self, s: str) -&gt; List[int]: match = [0] * len(s) c = 0 for i in range(1, len(s)): v = s[i] while c and s[c] != v: c = match[c - 1] if s[c] == v: c += 1 match[i] = c return match # KMP 模板 # 返回 text 中出现了多少次 pattern（允许 pattern 重叠） def kmp_search(self, text: str, pattern: str) -&gt; int: match = self.calc_max_match(pattern) match_cnt = c = 0 for i, v in enumerate(text): v = text[i] while c and pattern[c] != v: c = match[c - 1] if pattern[c] == v: c += 1 if c == len(pattern): match_cnt += 1 c = match[c - 1] return match_cnt作者：灵茶山艾府链接：https://leetcode.cn/problems/string-transformation/solutions/2435348/kmp-ju-zhen-kuai-su-mi-you-hua-dp-by-end-vypf/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 快速幂 模版(实现快速计算某个元素的幂)12345678910111213141516171819202122 # 矩阵乘法 def multiply(self, a: List[List[int]], b: List[List[int]]) -&gt; List[List[int]]: c = [[0, 0], [0, 0]] for i in range(2): for j in range(2): c[i][j] = (a[i][0] * b[0][j] + a[i][1] * b[1][j]) % (10 ** 9 + 7) return c # 矩阵快速幂 def pow(self, a: List[List[int]], n: int) -&gt; List[List[int]]: res = [[1, 0], [0, 1]] while n: if n % 2: res = self.multiply(res, a) a = self.multiply(a, a) n //= 2 return res作者：灵茶山艾府链接：https://leetcode.cn/problems/string-transformation/solutions/2435348/kmp-ju-zhen-kuai-su-mi-you-hua-dp-by-end-vypf/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2099/08/28/leetcode_%E6%A8%A1%E7%89%88/"},{"title":"计算机网络学习记录","text":"浅浅回顾一下计算机网络知识 计算机网络学习记录计算机网络的性能指标 速率：数据传送速率，往往指额定速率，非实际运行速率，bit/s 带宽：频域（100Hz-1000Hz）与时域（bit/s） 带宽就像一条高速公路，它的宽度决定了车辆（数据）能够同时通过的数量。而速率则类似于车辆在高速公路上的行驶速度，它决定了单位时间内能够通过的车辆（数据）数量。 吞吐量：单位时间内通过某个网络的实际数据量，受网络的带宽或网络的额定速率的限制 时延：指数据从网络的一端到另一端所需的时间。包括发送时延、传播时延、处理时延、排队时延 时延带宽积=传播时延 * 带宽，按比特计数的链路长度 往返时间 RTT（Round-Trip Time），表示从发送方发送完数据，到发送方收到来自接收方的确认总共的时间 利用率：信道利用率指百分之几的时间是被利用的。网络利用率指去啊网络的信道利用率的加权平均值 计算机网络体系架构 物理层作用：尽可能屏蔽掉不同传输媒体和通信手段的差异，为数据链路层提供一个接口主要任务：确定与传输媒体的接口有关的一些特性，数据终端设备（DTE）与数据电路终结设备（DCE）双绞线光纤 数据链路层作用：负责通过一条链路从一个结点向物理链路直接相连的相邻结点传送帧(链路层协议数据单元，封装网络层的数据包)主要任务：向下物理层提供的位流服务，向上向网络层提供明确的服务接口封装成帧、透明传输、差错控制 局域网中的数据链路层（重点以太网，以太网是一种协议） 以太网 MAC 地址 扩展以太网集线器是一层设备，冲突发生在一层，网桥交换机是二层设备。 vlan（虚拟局域网） 网络层数据链路层以太网一个帧最大长度 MTU 1500 bytes，所以 IP 数据不可能达到65535，所以会分片和重组一个接口一个 IP，不是一个主机一个 IP，你有多少网卡，就可以有多少 IP 传输层（运输层） 应用层","link":"/2023/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"摄影基础","text":"对于摄影的一些基础做一些记录 主流相机品牌历史与镜头卡口简介 摄影起源 法兰距 法兰距、电子触点和镜头内部直径的差异是造成各家相机卡口不通用的主要原因 无反相机拥有更短的法兰距，搭配更大的内径尺寸，无反相机的镜头在重量与光学性能有优势。 SONY A7 第一台无反相机 佳能世界第一台带有处理器的相机 AE-1，第一台带有超声波马达的相机 EOS650，自家第一台全画幅的数码单反 1DS，入门级单反 300D，奠定老大市场产品 5D2，2018年推出 EOS R系列，针对 R 系列推出 RF 卡口，法兰距从44缩短到20mm 佳能在数码时代主要三种卡口，EF 卡口主要适用于单反相机，EFM 卡口主要适用于 M 系列的无反相机，RF 卡口适用于最新的 EOS R 尼康 F，尼康 APS-C 画幅数码单反 D1，尼康全画幅相机 D3，2017年一代神机 D850，2018年推出全新的数码微单 Z7，从 F 卡口到 Z 卡口，内径从44mm提升到55mm，法兰距从46.5缩短到16mm，F转Z的内接环 富士 X 卡口，instax 系列是现在拍立得顶端，中画幅旗舰 GFX 系列，使用了 G 卡口，APS-C 画幅利用到了极致的 X 系列产品上，使用 XF 卡口。富士和哈苏成为了主流的中画幅旗舰品牌。富士没有全画幅。 松下 Lumix 世界第一台无反微单 G1，松下在视频领域顺风顺水，Lumix GH5、2018年发布 S1，S1R，从 M43 卡口到 L 卡口 奥林巴斯，全球首款半幅式单反相机 Olympus-PEN F，OM卡口，全球首款4/3系统的单反相机 E1，后使用 M43 卡口 适马 主要做镜头，体积最小最轻的全画幅相机，sd、fp系列用的 L 卡口，兼容徕卡和松下的很多镜头 理光间谍相机， GR 系列 宾得 PENTAX，m37、m42卡口，k卡口，Q卡口 三星 K 卡口，三星自家 NX 卡口，最后一款 NX500 哈苏（瑞典企业），阿波罗 11 号，被留在月球上，主要分为3个系统，x 系统是哈苏主流的中画幅无反系统，X1D 50C，使用 XCD 系列卡口镜头。H 系统是哈苏超高像素中画幅无反系列，使用 H 镜头，其中的 H6D-400c 4亿像素，40万人民币 徕卡，经典 M 系列，旁轴造型（巨好看！！！），M 卡口 康泰时（Contax）蔡司旗下，G 卡口，最新的 N 卡口 主流相机品牌特点 佳能（牙膏厂）屏幕素质高、镜头生态好，用起来很舒服，类似于苹果。 尼康（鞋厂）对消费者很大方，由日本匠人气质，固执和古板，视频不太行 索尼引领了无反时代，a7m 各方面很均衡，对焦无敌 富士有自己很独特的色彩科学 哈苏强强强、贵贵贵（21万），商业广告用的多 徕卡纪实摄影领域多 像素、画幅、防抖、对焦、续航、连拍速度、视频摄影、重量和体积","link":"/2023/10/08/%E6%91%84%E5%BD%B1%E5%9F%BA%E7%A1%80/"},{"title":"《Effective Python》笔记","text":"Effecitve Python 阅读 《Effective Python》笔记列表与字典11.学会对序列做切片 切片要尽可能写的简单，如果从头开始选，就省略起始下标0；如果选到片列末尾，省略终止下标 切片允许起始下标或终止下标越界，所以很容易就能表达“取开头多少个元素”或“取末尾多少个元素”，而不担心切片是否真有那么多元素 把切片放在赋值符号的左侧可以将原列表中这段范围内的元素用赋值符号右侧的元素替换掉，但可能改变原列表的长度 12.不要在切片里同时指定起止下标与步进 同时指定切片的起止下标与步进理解起来会很困难 如果要指定步进值，那就省略起止下标，最好采用正数作为步进值，尽量别用负数 不要把起始位置、终止位置与步进值全都写在同一个切片操作里。如果必须同时使用这三个指标，那就分两次（其中一次隔位选取、另一次做切割），也可以使用itertools中的islice方法 13.通过带星号的unpacking操作来捕获多个元素，不要用切片 拆分数据结构并把其中的数据赋给变量时，可以用带星号的表达式，将结构中无法与普通变量相匹配的内容捕获到一份列表里 这种带星号的表达式可以出现在赋值符号左侧的任意位置，它总是会形成一份含有零个或多个值的列表 这种带星号的unpacking方式比较清晰，通过下标或切片容易出错1234oldest. second_oldest, *others = car_ages_descendingprint(oldest, second_oldest, others)&gt;&gt;&gt;20 19 [15, 9, 8, 7, 6, 4, 1, 0] 14.用 sort 方法的 key 参数来表示复杂的排序逻辑 凡是具备自然顺序的内置类型几乎都可以用 sort 方法排列，例如字符串、浮点数 __repr__ 是 Python 中的一个特殊方法 (special method)，用于定义对象的 “official” 字符串表示形式。这个方法会在调用内置函数 repr() 时被调用，或者在交互式环境中直接输出对象时被自动调用。它的作用是返回一个可以用来重新创建对象的字符串表示形式。 !r 是一种格式说明符，用于在格式化字符串时表示要对值进行 “转换”。在这种情况下，!r 用于调用 repr() 函数来获得对象的“官方”字符串表示形式。f'Point({self.x!r}, {self.y})' 中的 !r 会确保 self.x 和 self.y 的值都使用它们的官方字符串表示形式，这在创建对象的字符串表示形式时非常有用。 可以把辅助函数传给 sort 方法的 key 参数，让 sort 根据函数逻辑来排列元素顺序，而不是根据元素本身1tools.sort(key=lambda x:x.name) 排序有很多指标要一句，可以把它们放在一个元组里，让key函数返回这样的元组，如果支持一元减操作符，可以单独给这项指标取反1tools.sort(key=lambda x:(-x.weight, x.name)) 如果这些指标不支持一元减操作符，可以多次调用 sort 方法，并在每次调用时分别指定 key 函数与 reverse 参数。最次要的放第一轮，重要的放最后12tools.sort(key=lambda x:(x.weight))tools.sort(key=lambda x:(x.name, reverse=True)) 15. 不要过分依赖字典添加条目时所用的顺序 在python3.5与之前版本，字典不保证迭代顺序与插入顺序一致。因为字典类型以前是用哈希表算法实现的。Python3.6开始，字典会保留这些键值对在添加时所用的顺序，3.7 语言规范正式确立了这条规则。 内置的 collections 模块早就能提供这种保留插入顺序的字典，叫做 OrderDict，和标准的 dict 很像，但是如果频繁插入或弹出键值对，那么 OrderDict 更适合。 Python 不是静态类型的语言，大多数代码都以鸭子类型（duck typing）机制运作（也就是说，对象支持什么样的行为，就可以当成什么样的数据使用，而不用执着于它在类体系中的地位） 对于不可变类型（例如整数、浮点数、字符串、元组等），传递的是值的副本，因此类似于深复制的概念。 对于可变类型（例如列表、字典、集合等），传递的是引用，因此类似于浅复制的概念，可能会对原始对象产生影响。 双下划线（例如 __xx__）开头和结尾的方法是特殊方法（也称为魔术方法或双下划线方法），特殊方法是 Python 中用于实现对象特定行为的机制，而普通方法则用于一般的对象行为和逻辑。 如果不想把这种跟标准字典类型很相似的类型也当作标准字典来处理，那么可以考虑三种办法。第一，不要依赖插入时的顺序代码，加一段顺序判断；第二，在程序运行时明确判断它是不是标准字典；第三，给代码添加类型注解并做静态分析123def popular_rank(votes: Dict[str, int], ranks: Dict[str, int]) -&gt; None:python3 -m mypy --strict example.py 16. 用 get 处理键不在字典中的情况，不要使用 in 与 KeyError 一般判断字典里面有没有这个 Key，可以采用 in 或者 KeyError123456789if key in counters: xxxelse: xxxtry: count = counters[key]except KeyError: count = 0 Python 内置的字典(dict)类型提供了get方法，可以通过第一个参数指定自己想查的键，并通过第二个参数指定这个键不存在时返回的默认值1count = counters.get(key, 0) dict 类型提供了 setdefault 方法。如果有就返回对应的值，如果没有就先把用户提供的默认值跟这个键关联起来12names = votes.setdefault(key, [])names.append(who) 17. 用defaultdict处理内部状态中缺失的元素，而不用setdefault 如果你管理的字典可能需要添加任意的键，那么应该考虑能否用内置的 collections 模块中的 defaultdict 实例来解决问题12345678910111213141516from collections import defaultdictclass Visits: def __init__(self): self.data = {} def add(self, country, city): city_set = self.data.setdefault(country, set()) city_set.add(city)class Visits: def __init__(self): self.data = defaultdict(set) def add(self, country, city): self.data[country].add(city) 18. 学会利用__missig__构造依赖值的默认值 如果创建默认值需要较大的开销，或者可能抛出异常，那就不适合使用dict类型的setdefault方法实现 传给defaultdict的函数必须是不需要参数的函数，所以无法创建出需要依赖键名的默认值 如果要构造的默认值必须根据键名来确定，那么可以定义自己的dict子类并实现__missing__方法123456789class Pictures(dict): def __missinng__(self, key): value = open_picture(key) self[key] = valu return valuepictures = Pictures()handlie = pictures[path]handle.seek(0)image_data = handle.read() 函数19. 不要把函数返回的多个数值拆分到三个以上的变量中 函数可以把多个值合起来通过一个元组返回给调用者，以便利用Python的 unpacking 机制去拆分 对于函数返回的多个值，可以把普通变量没有捕获到的那些值全都捕获到一个带星号的变量中 把返回的值拆分到四个或四个以上的变量很容易出错，所以最好不要啊么些，而是应该通过小类或 namedtuple 实例完成 20. 遇到意外状况时应该抛出异常，不要返回 None 用返回值 None 表示特殊情况时很容易出错的，没办法与0和空白字符串之类的值区分，这些值都相当于 False 用异常表示特殊的情况，而不要返回 None。让调用这个函数的程序根据文档里写的异常情况做出处理 通过类型注解可以明确禁止函数返回 None，即便在特殊情况下，它也不能返回这个值12345678910111213141516171819202122232425def careful_divide(a, b): try: return a/b except ZeroDivisionError: return Nonedef careful_divide(a, b): try: return a/b except ZeroDivisionError: return False, Nonedef careful_divide(a, b): try: return a/b except ZeroDivisionError: raise ValueError('Invalid inputs')x,y = 5,2try: result = careful_divide(a,b)except ValueError: print('Invalid inputs')else: print(result) 21. 了解如何在闭包里面使用外围作用域中的变量1234567891011121314def sort_priority(values, group): def helper(x): if x in group: return (0,x) return (1,x) values.sort(key=helper)numbers = [8,3,1,2,5,4,7,6]group = {2,3,5,7}sort_priority(numbers, group)print(numbers)&gt;&gt;&gt;[2,3,5,7,1,4,6,8] 上述写法，为什么能成功 python 支持闭包，大函数里面的小函数也能引用大函数之中的变量 函数在 Python 里是头等对象，所以你可以像操作其它对象一样，直接引用它们、把它们赋给变量、将它们当成参数传给其他函数，或是在in表达式比较等等。 python 在判断两个序列（包括元组）的大小时，有自己的一套规则。它首先比较0号位置的那两个元素，如果相等，那就比较1号位置的那两个元素；依次类推 在表达式中引用变量时，Python解释器会按照下面顺序，在作用域查找变量 1）当前函数的作用域 2）外围作用域（例如包含当前函数的其他函数所对应的作用域） 3）包含当前代码的那个模块所对应的作用域（也叫全局作用域，global scope） 4）内置作用域（built-in scope，也就是包含 len 与 str 等函数的那个作用域） 变量赋值不同，如果变量已经定义在当前作用域中，那么直接把新值赋给他就好。如果当前域不存在这个变量，即便外围作用域里有同名的变量，Python也还是会吧这次的赋值当成新变量的定义 上述问题也称作作用域bug，python 是故意这么设计的，防止函数中的局部变量污染外围模块 Python 里面有一种特殊的写法，可以把闭包里的数据赋给闭包外的变量。用 nonlocal,但是nonlocal不能侵染模块级别的作用域12345678910def sort_priority3(numbers, group): found = False def helper(x): nonlocal found if x in group: found = True return (0,x) return (1,x) numbers.sort(key=helper) return found nonlocal 表明要把数据赋给闭包外的变量，global 表明放到模块作用域中 22. 用数量可变的位置参数给函数设计清晰的参数列表 让函数接受数量可变的位置参数(positional argument)，在python里，可以给最后一个位置参数加前缀*，这样调用者只需要提供不带星号的那些参数，然后可以不再指其他参数。123456789101112131415161718def log(message, values): if not values: print(message) else: values_str = ', 'join(str(x) for x in values) print(f'{message}: {values_str}')log('My numbers are',[1,2])log('Hi there', [])def log(message, *values): if not values: print(message) else: values_str = ', 'join(str(x) for x in values) print(f'{message}: {values_str}')log('My numbers are',1,2)log('Hi there') 如果想把已有序列里面的元素当成参数传给像参数个数可变的函数，那么可以在传递序列的时采用*操作符12fav = [7,33,99]log('Favorite colors',*fav) 如果*操作符加在生成器前，那么传递参数时，程序有可能因为耗尽内存而崩溃 给接受 *args 的函数添加新位置参数，可能导致难以排查的bug 23. 用关键字参数来表示可选的行为 如果有一份字典，那么可以把**运算符加在字典前面，这会让Python把字典里面的键值以关键词的形式传给函数12345678910111213my_kwargs = { 'number':20 'divisor':7}assert remainder(**my_kwargs) == 6my_kwargs = { 'number':20}other_kwargs = { 'divisor':7}assert remainder(**my_kwargs, **other_kwargs) == 6 关键字参数的灵活用法可以带来三个好处 用关键字参数调用函数可以让初次阅读代码的人更容易看懂 可以带有默认值，该值是在定义函数时指定的 可以很灵活地扩充函数的参数，而不用担心会影响原有的函数调用代码 24.用 None 和 docstring 来描述默认值会变的参数 参数的默认值只会在系统加载这个模块的时候，计算一遍，而不会在每次执行时都重新计算，这通常意味着这些默认值在程序启动后，就已经定下来了，例如下面这个例子，datetime.now() 是不会重新计算的123456def log(message, when=datetime.now()): print(f'{when}:{message}')log('HI there')sleep(0.1)log('Hello again') 改成下面这样就可以实现time的变化了12345678def log(message, when=None): if when is None: when = datetime.now() print(f'{when}:{message}')log('HI there')sleep(0.1)log('Hello again') 默认值为 None 的关键字参数，也可以添加类型注解12345678def log(message:str, when=Optional[datetime]=None) -&gt; None: if when is None: when = datetime.now() print(f'{when}:{message}')log('HI there')sleep(0.1)log('Hello again') 如果关键字参数的默认值属于这种会发生变化的值，那就应该写成 None，并且要在 docstring 里面描述函数此时的默认行为 25.用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表 对于参数比较复杂的函数，我们可以声明只能通过关键字指定的参数（keyword-only argument），这种参数只能用关键字来指定，不能按位置传递，参数列表里的 * 符号把参数分为两组，左边是位置参数，右边是只能用关键字指定的参数。1def safe_division_c(number, divisor, * , ignore_overflow=False, ignore_zero_division = False): Python3.8 引入了一项新特性，可以解决这个问题，这就是只能按位置传递的参数(positional-only argument)，参数列表中的 / 符号，表示他左边的那些参数只能按位置指定1def safe_division_c(number, divisor, /, * , ignore_overflow=False, ignore_zero_division = False): /和* 中间的参数就是既可以按照位置也可以按照关键字指定的参数 26.用functools.wraps定义函数修饰器 Python 可以使用修饰器来封装某个函数，从而让程序在执行这个函数之前与执行完这个函数后，分别运行某些代码。这是个很有用的机制，能够确保以正确的方式使用函数。12345678910111213def trace(func): def wrapper(*args, **kwargs): result = func(*args, **kwargs) print(f'{func.__name__}(args!r, {kwargs!r}) ' f'-&gt; {result!r}') return result return wrapper@tracedef fibonacci(n): if n in (0,1): return n return (fibonacci(n-1) + fibonacci(n-2)) 上述存在几个问题 干扰那些需要利用 introspection 机制来运作的工具，例如调试器 help()函数打印出来不是我们想看的文档 对象序列化器也无法正常运作 可以使用 functools 内置模块之中的 wraps 辅助函数，wraps本身就是一个修饰器123456789from functools import wrapsdef trace(func): @wraps(func) def wrapp......@tracedef fibo..... 推导与生成27. 让列表推导取代map与filter Python经常需要处理list、dict、set等数据结构，并且要以这种处理逻辑为基础来构建程序，叫做推导。运用到函数上产生了生成器（generator） 12345678910a = [1,2,3]squ = []for x in a: squ.append(x**2)print(squ)squ = [x**2 for x in a]print(squ) map(square, numbers) 会返回一个迭代器，其中包含了列表 numbers 中每个元素经过 square 函数处理后的结果。123456def square(x): return x * x numbers = [1, 2, 3, 4, 5] squared = map(square, numbers) print(list(squared)) # 输出：[1, 4, 9, 16, 25] 字典和集合也可以通过推导生成 28. 控制推导逻辑的子表达式不要超过两个 列表推导还支持多层循环，例如把二维列表转换成一维列表，每层循环还可以带有多个条件12matrix = [[1,2,3],[4,5,6],[7,8,9]]flat = [x for row in matrix for x in row] 控制推导逻辑的子表达式不要超过两个（例如两个if条件），如果实现的逻辑比这还复杂，那应该采用普通的 if 和 for 实现，并且可以使用辅助函数。 29. 用赋值表达式消除推导中的重复代码 编写推导式与生成器表达式时，可以在描述条件的那一部分通过赋值表达式定义变量，并在其他部分复用该变量，可使程序简单易读 对于推导式与生成器表达式来说，虽然赋值表达式也可以出现在描述条件的那一部分之外，但最好别这么写 30. 不要让函数直接返回列表，应该让它逐个生成列表里的值12345678910111213141516def index_words(text): result = [] if text: result.append(0) for index, letter in enumerate(text): if letter == ' ': result.append(index+1) return resultdef index_words_iter(text): if text: yield 0 for index, letter in enumerate(text): if letter == ' ': yield index + 1 这种函数改用生成器来实现会更好，调用生成器不会让其中的代码立刻执行，会返回一个迭代器给 Python 的内置函数 next 函数 如果不用生成器，就必须把所有的结果保存到列表中，然后才能返回列表。如果数据特别多，程序可能会因为耗尽内存而崩溃 定义生成器函数的时候，有一点需要注意，调用者无法重复使用函数所返回的迭代器，因为这些迭代器是有状态的 31. 谨慎地迭代函数所收到的参数 正常迭代器在已经把数据耗完的迭代器上面继续迭代，程序不报错 Python 的 for 循环及相关表达式，正是按照迭代器协议来遍历容器内容的。Python执行for x in foo 这样的语句时，实际会调用iter(foo)，也就是把foo传给内置的iter函数。这个函数会触发名为foo.__iter__的特殊方法，该方法必须返回迭代器对象（这个对象本身要实现_next_特殊方法），最后 Python 会用迭代器对象反复调用内置的 next 函数，直到数据耗尽为止。如下12345678class ReadVisits: def __init__(self, data_path): self.data_path = data_path def __iter__(self): with open(self.data_path) as f: for line in f: yield int(line) 可以把值传给iter函数，检测它返回的是不是那个值本身。如果是，就说明这是个普通的迭代器，而不是一个可以迭代的容器。另外，也可以用内置的 isinstance 函数判断该值是不是 collection.abc.Iterator 类的实例","link":"/2023/10/15/Effective%20Python%20%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"},{"title":"Linux 知识复习","text":"Linux 复习 Linux 与 Unix 三种网络模式 虚拟机快照 Linux 目录结构（Linux 世界里，一切皆目录） VIM 用户管理 运行级别 如何找回 root 密码 文件目录类 文件压缩 Linux 组和权限 定时任务调度 Linux 磁盘分区 网络配置 进程 服务管理","link":"/2023/10/17/Linux%20%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"},{"title":"《数字银行安全体系构建》读书笔记","text":"很开心可以在新的一年中，以这样一本书开场，联系业界，将现在的国家重点研发项目，不断改进，不断总结 《数字银行安全体系构建》数字银行安全体系设计 安全体系的有效性 安全目标与方向的正确性 安全责任范围是否明确 安全体系的合理性与完备性 安全资源投入度与重点风险的匹配度 安全能力与风险的匹配度 安全能力覆盖率与持续有效性 CAP理论：一个分布式系统最多只能同时满足一致性(Consistency)、可用性(Availabitlity)和分区容错性(Partition tolerace)这三项中的两项 风险类型：已知风险和未知风险、存量风险和增量风险、软件风险和硬件风险、可控风险和不可控风险、外部攻击风险和内部威胁风险、有特征攻击风险和无特征攻击风险 风险阶段：事前安全威胁的识别、安全意识的提升、上线前的风险规避机制，上线后的安全防护、风险利用时的感知与应急止血，以及红蓝演练的持续检验，事后的溯源和司法打击 默认安全（上线前规避已知风险） 上线前规避风险在风险治理和成本上都最优 一切目标实体的变更都可产生安全风险 现实中大部分安全事件都是由一只安全风险导致的 默认安全体系由增量风险管控和存量风险治理组成： 增量风险管控：通常由不符合安全要求的需求、代码、策略、权限等引起，当实体的状态发生变化时，往往会伴随新风险的产生，如何在实体变更过程中识别、修复和抵御这些风险，以此目标为导向的一系列全面、整体的安全规范和措施就是默认安全机制的体现 存量风险治理：建立线上风险巡检能力，对已知的安全风险进行全天候巡检，指定风险处置标准流程，涵盖风险的发现、修复、验证等环节 引入安全风险的变更类型分为需求设计、应用迭代、网络资源、计算资源、存储资源、策略配置、人力资源 改变安全在研发生命周期中被动的局面： 第一时间知道业务变更 高效地发现变更中的安全风险 1）风险识别：业务场景、历史漏洞数据、安全风险扫描能力、安全防护能力构建风险矩阵图 2）风险修复 3）修复验证环节 在上线前默认集成全链路的安全防护能力 1）基础安全基线（存储资源的安全策略、镜像签名和容器加固） 2）接入层（HTTPS、WAF、办公网零信任、前端安全响应头） 3）运行时的可信纵深防御（RASP应用运行时的自我保护、链路加密、服务鉴权、容器应用可信、出口流量管控） 4）业务层（RDS人机识别系统、业务逻辑防护） 上线前最后的准入管控 默认安全建设方案安全资产建设 识别哪些资产需要防护、识别资产上存在的风险、对风险进行治理与防护，并度量整体资产风险水平 传统定义中的资产主要包括域名、IP、虚拟机、容器、物理机、负载均衡器、数据库、代码库 安全资产的粒度应该细化到什么程度呢？笔者认为应该细化到可以直接进入实质漏洞挖掘阶段的程度。如域名 IP 相关的 Web 应用或 RPC 服务，需要细化到有哪些接口地址；虚拟机、容器需要细化到有哪些常驻进程、开端口，以及有什么系统软件包、业务进程相关的依赖。 数据资产 数据资产盘点是风险治理的基石 （1）数据资产的范围 （2）数据资产的分类分级 （3）数据链路可视化 数据资产风险治理 （1）数据风险地图 （2）数据流动的合规管控 （3）支持安全威胁感知与响应运营 不可忽视的大数据平台类资产 （1）数据存储类的各种大数据计算集群（如hadoop）、机器学习相关的 GPU 集群，虽然底层硬件资源依然是基于物理机、虚拟机、容器构建等，但从安全角度，前面提到的细化资产的方法已经不再适用。因为业务流量完全体现不出来的细节，在机器内部也看不到可疑、暴露的端口服务，真正攻击存在于应用内或应用间的数据流转。 （2）安全风险依附于资产而存在，在这种新形态下也不为例外。可以着重加强代码库、镜像、供应链相关的收集能力，毕竟最终风险还是大概率会在研发的代码、镜像中的软件、供应链的依赖组件。 防护组件默认集成 防护默认集成 （1）可信纵深防御：只有预期内的业务行为才能被允许执行，非预期的业务行为均被阻断 （2）自动化接入：默认防护的目标是应用（关联的 VIP、容器等）上线前默认具备现有的安全防护能力，避免因防护能力未覆盖或防护不及时导致的入侵事件 安全准入 所谓准入，是指只有符合预期的变更才能够被允许在生产环境执行。符合预期可以理解为，变更经过安全评估、确认无风险或已知风险被修复、具备一定的未知风险防御能力。 设计了一套完整的 VIP 准入完整方案，包括 （1）产品研发：重点关注与端产品底层相关的基础安全能力，如协议的通信加密、加签、安全探针、设备指纹 （2）产品编译：重点关注编译阶段中需要引入的框架安全配置，特别是运行时防护产品 （3）产品打包产物：重点关注产品打包后的安全加固配置，如代码混淆、符号混淆、防注入、防动态调试等 默认安全治理应用实践 面临的软件供应链风险 信息安全风险：软件供应链攻击 内容安全风险：政治主张、恶意破坏性代码 质量及长期支持风险：软件产品得不到长期保障 知识产权风险 软件供应链产品可分为六部分，这里重点分析以下内容 1）日常办公使用的各类工具、软件 2）各类三方组件：开源组件（Fastjson、Log4j），外购SDK 3）各类三方软件：开源软件（Jenkins），外购软件 可信纵深防御概念及架构","link":"/2024/01/02/%E3%80%8A%E6%95%B0%E5%AD%97%E9%93%B6%E8%A1%8C%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"作者直播分享《数字银行安全体系构建》","text":"听张欧总对于整体网商银行在安全方面的一个总结，并进行了QA 《数字银行安全体系构建》主要观点（QA） 在准入环节做了很大功夫，从而可以做到对于默认安全中所谓的平台变更，可以做到全方位感知 对于知识图谱以及大模型 AI 持非常乐观的态度，目前知识图谱已经有所应用，但工作还不够成熟，没有展开说 现在不存在所谓的传统银行 对于上级的汇报主要指标，主要还是安全水位以及覆盖风险的级别，虽然上级只关心出没出事儿 数字化转型的加深，风险暴露一定会越来越多。监管会越来愈关注，合规本质和风险控制一样得。落地过程中，会有差异 敏感数据全方位管控，无论主动还是被动。本质可以理解成一个网关。WAF 层面，全流量监测，终端监测，业务网关监测 重要 PPT","link":"/2024/01/22/%E4%BD%9C%E8%80%85%E5%88%86%E4%BA%AB%E3%80%8A%E6%95%B0%E5%AD%97%E9%93%B6%E8%A1%8C%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA%E3%80%8B/"}],"tags":[{"name":"英语 留学","slug":"英语-留学","link":"/tags/%E8%8B%B1%E8%AF%AD-%E7%95%99%E5%AD%A6/"},{"name":"基础知识","slug":"基础知识","link":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"阅读","slug":"阅读","link":"/tags/%E9%98%85%E8%AF%BB/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","link":"/tags/%E4%BB%A3%E7%A0%81/"},{"name":"数据生成","slug":"数据生成","link":"/tags/%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90/"},{"name":"差分隐私","slug":"差分隐私","link":"/tags/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/"},{"name":"数据蒸馏","slug":"数据蒸馏","link":"/tags/%E6%95%B0%E6%8D%AE%E8%92%B8%E9%A6%8F/"},{"name":"知识图谱 国重项目","slug":"知识图谱-国重项目","link":"/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E5%9B%BD%E9%87%8D%E9%A1%B9%E7%9B%AE/"},{"name":"论文评审","slug":"论文评审","link":"/tags/%E8%AE%BA%E6%96%87%E8%AF%84%E5%AE%A1/"},{"name":"篮球裁判","slug":"篮球裁判","link":"/tags/%E7%AF%AE%E7%90%83%E8%A3%81%E5%88%A4/"},{"name":"科研","slug":"科研","link":"/tags/%E7%A7%91%E7%A0%94/"},{"name":"服务器","slug":"服务器","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"数据安全","slug":"数据安全","link":"/tags/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/"},{"name":"xgboost","slug":"xgboost","link":"/tags/xgboost/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"摄影","slug":"摄影","link":"/tags/%E6%91%84%E5%BD%B1/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"安全","slug":"安全","link":"/tags/%E5%AE%89%E5%85%A8/"},{"name":"企业安全","slug":"企业安全","link":"/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"}],"categories":[],"pages":[{"title":"","text":"Hi there 👋，I am TaoI am a PhD student in the School of network and information security, Xidian University.","link":"/about/index.html"}]}