{"posts":[{"title":"IETLS 学习","text":"Just for myself! 只有 14% 的学生可以拿到 7 分以上 口语和写作重点强化 听力和阅读最少 8 分 雅思考试内容 听力 阅读 写作 口语 听力 Step one: 第一天，按照雅思考试的流程进行练习，听完整个一个test 的内容。之后，对照答案，只标出对错，但是不改正答案。 Step two: 第二天，分析整个test 里的错题。把错误的题重新听一下做一遍。 Step three: 直接能改正好的题，跳过。不能改正好的题，听写题目所在的内容。 Step four: 听写的时候，一句一停顿，听完一遍之后重复播放，直到自己认为写全了原文内容为止。之后，和听力原文对照，重点看写的不对的地方，同时分析错误的原因。 Step five：改完所有的错题，翻到听力原文的部分，把自己认为听的不好的section 看着听力原文通听一遍。一边听，一边标记出自己认为听得不太清楚的表达。 每日6分钟 加上一套练习 阅读 精读配合泛读 两天一套 test 每两天一套test: 第一天按时1 hour 完成，第二天分析题目 0-12 mins: 完成part 1，并填好相应答题卡 12-30 mins: 完成part 2, 并填好相应答题卡 30-55 mins: 完成 part 3, 并填好相应答题卡 55-60 mins: 检查自己的答案，查缺补漏 每日练习真题，按照上面的来 写作 小作文 每种看几篇范文，记下表达方式与框架 大作文 练就完事了 前期先看，跟着那本书走 口语 top sentence+ explain + example + conclusion/results 自己的理解 (7.0 分标准)： Fluency and Coherence: 1. 减少停顿和中途思考的时间 2. 尽量减少自我更正的次数 3. 回答中使用连接词过渡 4. 多表达，展示自己用英语交流的兴趣 5. 详细展开答案 Lexical Resource: 1. 描述同一事物时用不同的表达方法 2. 多用副词，形容词等修饰性词 3. 多用词伙（collocations） Grammatical Range and Accuracy: 1. 用不同的句式，复杂句和简单句交替使用 2. 减少语法错误 Pronunciation: 1. 不要纠结口音 2. 发音清晰 前期跟着那本书走，后期开练 10月19号（天气晴，心情良）List 1 physician n.内科医生 resort n.求助 excavate vt.挖掘 mutual a.相互的 impart vt.给予 forfeit v.（因犯规等而）丧失，失去 n.罚款 intermediate a.中间的 10月20号（天气🌞，心情良）List 2 regional a.局部范围的 preserve vt.保护；维持；保存；保藏 item n.条款 fabrication n.捏造 tram n.有轨电车 V.乘电车 maturity n.成熟 evacuate v.疏离 surge v.蜂拥而出 n.洋溢 10月23号（天气🌞，心情良）List 3 impede vt.阻碍 deduce v.演绎 doctorate n.博士学位 internship n.实习生身份 notion n.概念 lavatory n.厕所 irritation n.激怒 induce vt.引诱；引起 slit n.淤泥 10 月 24 日（天气晴，心情ok） reservation n.保留意见；预定 reasonable a.合理的 abode n.房屋 gadget n.小巧的器械；小玩意 strike v.打；折磨；罢工 dispute n.争论v.争论 exclusively ad.专门的 feather n.羽毛 10 月 26 日（天气晴，心情ok） vertebrate n.脊椎动物 industrious a.勤奋的 intestine n.肠 outpost n.前哨 consignment n.委托；投递 convention n.大会 humble a.谦逊的 divisional a.部门的 regulate v.管制；调节 10 月 27 日（天气阴，心情一般） discretion n.判断力 substitute v.代替 n.代替者 striking a.显著的 pirate n.侵犯版权者，海盗 vt.盗用 decrepit a.破旧的 ignorant a .无知的 leopard n.豹，美洲豹 mastery n.精通 recruit v.招募；复原；补充 n.新兵 gloss n.光泽 representation n.代理人 a.典型的 thrive vi.兴旺 consequently ad.因而 withstand vt.抵挡 anthoropologist n.人类学家 suitably ad.合适的 10 月 28 日（天气雨，心情一般） pulley n.滑轮 privilege n.特权 vt.给予特权 qualification n.资格；技能；条件；合格证 expand v.膨胀；详述 intern vt.拘禁，软禁 specialist n.专家 migratory a.迁徙的 inlet n.入口；水湾 hazard n.危险，冒险 v.冒…风险 alight a.点着的 vi.降落 shrewd a.机灵的 explosive n.爆炸物 a.爆炸的 inherent a.内在的 lever vt.撬动 n.杠杆 latent a.潜在的 11 月 2 日（天气晴，心情一般） ​ tenant n. 承租人 psychiatric a.精神病的 bolster vt.支持；改善；n.垫子 exotic a.外来的；奇异的；醒目的；吸引人的 evaporate a.蒸发；消失 virtually ad.几乎；实际上 tangibly ad.可触摸的 windscreen n.挡风玻璃 alluvial a.冲击的，淤积的 fossil n.化石 execution n.执行 11 月 4 日（天气晴，心情一般） heritage n.遗产 depict vt.描述 dormancy n.休眠 cope vi.（成功的）应付；处理 decay n.分发；配给物 v.腐烂 defect n.缺点；vi.叛变 excusable a.可原谅的 11 月 5 日（天气阴，心情一般） atmospheric a.大气的 corrode v.腐蚀 antidote n.解毒药 turret n.塔楼 elastic a.有弹性的；灵活的 n.松紧带 redundant a.多余的 suppression n.镇压 naked a.裸体的 nourish vt.养育 11 月 9 日（天气阴，心情一般） flourish v.繁茂；茂盛；n.夸张动作 gravel n.沙砾 insulation n.隔绝；绝缘 undermine vt.削弱 eliminate vt.消灭 apparently ad.显然 gelatin n.明胶 stimulate vt.刺激；激发 fuel n.燃料 probation n.缓刑；试用期 devastate vt.破坏 tropical a.热带的 endeavour n/vi 努力；尝试 11 月 10 日（天气晴，心情一般） illuminate vt.照亮 warrant v.保证 n.授权 verdict n.裁定 refresher n.提神物 administrative a.管理的 deputy n.代理人 fragrance n.芳香；香水 unyielding a.顽强的 11 月 11 日（天气晴，心情一般） formulate vt.系统阐述；构想出 creep vi.悄悄移动；爬行 casual a.偶然的 interpretation n.口译 furnish vt.布置；供应 stabilise v.稳定 narrator n.讲述者 reckon v.认为 11 月 13 日（天气晴，心情一般） exaggerate v.夸大 magnetic a.磁的；有吸引力的 graphic a.文字的；生动的；绘画的 stimulus n.刺激 roam v.随便走；徜徉 n.漫步 provided conj. 倘若；只要 publicity n.宣传 composition n.作品；组成 damp a.潮湿的 n.潮湿 homogeneous a.同种类的 terrace n.阳台 11 月 16 日（天气晴，心情一般） fumes n.烟，气 liberty n.自由 poll n.民意测验 refundable a.可退换的 glide vi/n 滑行 mattress n.床垫 digestive a.消化的 practically ad.几乎 foremost a.最好的 11 月 17 日（天气晴，心情一般） ​ plagiarism n.剽窃，抄袭 pledge v.正式承诺；发誓 n.誓约 vessel n.船只 stereo a.立体声的 11 月 21 日（天气晴，心情一般） aesthetic a.美学的 recreation n.娱乐 perceive vt.感知 proportion n.比例；部分 offset vt.抵消 intact a.完整无缺的 siesta n.午睡 detour n.弯路 11 月 23 日（天气晴，心情一般） cosmic a.宇宙的 supervisor n.监督人 permanent a.永久的 embed vt.使深留脑中 deprive vt.剥夺 amaze vt.使惊奇 asset n.财产 sophisticated a.老于世故的；精密的 intimate a.亲密的 n.至交 vt.暗示 calibre n.质量；口径 harsh a.严厉的 parliament n.议会 11 月 24 日（天气晴，心情一般） dweller n.居住者 coverage n.新闻报道；覆盖范围 specialty n.特产 intrinsic a.固有的；本质的 turnover n.营业额；人事变动率 lateral a.侧面的 export v.出口 n.出口 marvellous ad.令人惊奇的；奇特的；奇迹般的 tribute n.贡品；称赞 11 月 25 日（天气晴，心情一般） primitive a.原始的；简单的 n.原始人 barge n.驳船v.猛闯 aerobics n.有氧 exacerbate vt.恶化 crater n.火山口 11 月 26 日（天气晴，心情一般） flexibility n.柔韧；柔顺；灵活性 controversy n.争论 sensation n.感觉能力 recipient n.接受者 identical a.完全相同的 tropospheric a.对流层的 predominantly ad.主要地 11 月 27 日（天气晴，心情一般） mineral n.矿物 moderation n.温和；适度 vocational a.职业的 coffer n.保险箱 turbine n.涡轮机 compatible a.兼容的 proposal n.提议 audacious a.大胆的 tramp v.跋涉 pest n.害虫 12月1日（天气雨，心情一般） amount n.总额 vi.合计 manipulate vt.应付；操纵；影响 juvenile a.少年的 vulnerable a.易受攻击的 steam n.气雾 v.发出蒸汽；行驶 valuable a.贵重的，有价值的 n.贵重物品 sanctuary n.圣堂；庇护所 12月2日（天气雨，心情🉑️） deception n.欺骗；诡计 terrain n.地形 overwhelm vt.征服 bump into 不期而遇 miserable a.悲惨的 pliable a.容易受人影响的 disposal n.处理；布置 subsidiary n.子公司 feeble a.虚弱的 nominal a.名义上的 12月3日（天气❄️，心情🉑️） gross a.总的 refusal n.拒绝 coupon n.优惠券 expectancy n.期待 genuine a.真正的 12月3日（天气阴，心情🉑️） slope n.斜坡 prey n.猎物；牺牲品 screw v.用螺丝固定 n.螺丝 delicate a.纤细的 venture v.敢于去 n.风险投资 shrink v.收缩 12月6日（天气☀️，心情🉑️） flip v.轻弹 provision n.供应 internist n.内科医生 prospective a.预期的；未来的；可能的 stammer n.结巴 fickle a.易变的 12月8日（天气☀️，心情🉑️） prevail vi.流行，盛行；占优势 mansion n.大厦 deficiency n.缺乏 sensational a.轰动性的；耸人听闻的；极好的 pretension n.声称；自负 detach v.分开 torrent n.洪流 inspect vt.检阅 12月11日（天气☀️，心情🉑️） sediment n.沉淀物；沉积物 resit v/n.重修 menace n.威胁；危险的人 vt.威胁到 contain vt.包含；控制，阻止 fasten v.扎牢 scratch n.划伤，抓痕 v.抓；划破 mammal n.哺乳动物 serial n.连续剧 a.连续的 jungle n.丛林 optical a.视力的 retail n.零售 v.零售 transcation n.办理；处理；交易 [pl.]会报 12月14日（天气☀️，心情🉑️） germ n.微生物；起源 spade n.铁锹 parcel n.包裹 vice verse 反而亦然 foetus n.胎儿 stationery n.文具 12月16日（天气☀️，心情🉑️） impulse n.冲动；刺激；脉冲 imcapacitate vt.使无能为力；使伤残 conceive v.想出，构想；怀孕 course n.过程；路线；跑道 v.追猎 degrade v.降级；堕落；降解；退化 partical n.极少量 gorge v.狼吞虎咽，塞饱 n.峡谷 recreational a.消遣的；游戏的 12月21日（天气☀️，心情🉑️） seal vt.封，密封 n.封铅；图章；海豹 scarce a.缺乏的；罕见的 exclusive a.奢华的；独有的；排他的 n.独家新闻 vertical a.垂直的 n.垂直线 flat a.平的；固定的 fracture n.断裂；骨折 v.断裂 12月29日（天气☀️，心情🉑️） glacial a.冰期的；寒冷的 teem vi.倾泻 exhibition n.展览 whereas conj.然而 poultry n.家禽 postgraduate n.研究生 premuim a.高级的 n.保险费 1月7日（天气☀️，心情🉑️） discerning a.有识别力的 chill n.寒意 a.寒冷的 exposure n.暴露；接触 premium a.高级的 deceive v.欺骗 facility n.设备 statue n.塑像 1月8日（天气☀️，心情🉑️） simultaneous a.同时的 sundial n.日晷 dormant a.休眠的 engrave vt.雕刻 territory n.领土 1月11日（天气☀️，心情🉑️） hallowed a.受尊敬的 bring around /round 说服；使恢复知觉 relevance n.中肯；相关性 reluctant a.不情愿的 laterality n.对一侧面的偏重 integral a.不可或缺的 sporadically ad.偶发的 expedition n.远征；旅行；远征队 1月12日（天气☀️，心情🉑️） postpone v.延迟，延期 aggravation n.加重 lull n.间歇 plush a.豪华的 dispense vt.分发 charter n.纲领；宪章 1月14日（天气☀️，心情🉑️） thigh n.大腿 entrust vt.委托 pamper vt.纵容；精心护理 veterinarian n.兽医 derelict a.被抛弃的 n.遗弃物 synchronise v.同步发生 ornamental a.装饰性的 irritate vt.使烦躁；刺激 initiative n.倡议；主动性；主动权 rotate v.（使）旋转，转动；轮流 1月15日（天气☀️，心情🉑️） destination n.目的地 in accordance with 按照 envisage vt.展望 binoculars n.双筒望远镜 glutamate n.谷氨酸 erroneous a.错误的 robust a.健壮的 indigenous a.土产的 sympathetic a.同情的 1月18日（天气☀️，心情🉑️） gleam vi.闪烁 sole a.唯一的 rudimentary a.基本的；未充分发展的 ritual n.典礼 interpret v.解释 preliminary a.开端的 turbid a.混沌的","link":"/2020/10/01/IELTS/"},{"title":"Makefile 使用","text":"简单易忘的知识记录 Makefile 基础的 Makefile 规则 target … : prerequisites … command … … target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。 prerequisites就是，要生成那个target所需要的文件或是目标。 command也就是make需要执行的命令。（任意的Shell命令） 在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。 在我们的makefile中以“$(objects)”的方式来使用这个变量 .PHONY : clean clean : -rm edit $(objects) 前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。！ Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 1、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 2、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。 3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。 4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 5、注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“/#”。 最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。 Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。目录由 ：号分割。","link":"/2020/07/07/base_knowledge/"},{"title":"每日阅读","text":"还是擦肩天桥上，无意间的回眸 每日阅读9 月 17 日（天气晴）[技术分享】Android代码混淆技术总结（一）(https://www.anquanke.com/post/id/85843) 控制流平坦化：在不改变源代码的功能前提下，将 C 或 C++ 代码中控制语句转换成 switch 分支语句，使更加复杂 目前使用的比较多的 OLLVM 的开源混淆方案，其中包括控制流平坦化、虚假控制流和指令替换 花指令：花指令是位于永远不能执行的路径中，且是不完整指令而已。运行过程中，因为执行不到所以不会影响整体功能，但是若是反汇编工具的话，因为是静态反汇编就会失败。 标识符混淆：对源程序的包名、类名、方法名和变量名进行重命名，用无意义的标识符来替代。 常用的 ProGuard 工具 字符串混淆；对于源程序的比较关键的字符串变量进行混淆，一种是 Java 层的字符串，另一种是native层 编码混淆、加密处理 红队安全研发系列之免杀原理和绕过研究——起始(https://www.anquanke.com/post/id/217529) 静态查杀分为已知类型查杀与未知类型查杀 已知类型查杀——特征码查杀，按照指定模式进行特征匹配的算法，而具体使用什么类型的规则（既各种扫描算法）取决于扫描器，例如YARA规则。YARA是一款旨在帮助恶意软件研究人员识别和分类恶意软件样本的开源工具 未知类型查杀——静态启发式查杀，启发式查杀是对单一特征码查杀的补充，解决未知病毒查杀。早期杀软都是发现病毒，制作该病毒的特征码，但是对于未知病毒就无法查杀，而启发式则是将一类病毒总结后，归纳其特征，其后的演变都为一类病毒，这既是启发式算法。 动态查杀分为指定类型查杀与聚类类型查杀。某杀软查杀cobaltstrike等知名远控则是通过shell code内存匹配来进行查杀。 9 月 18 日（天气☀️，心情😄）JSON Web Token（JWT）攻击技巧 JWT 是一个轻量级业务流程管理规范，允许用户和服务器之间可靠传递消息。通常实现前端和后端的解藕，同时，它还可以与Restful API 一起使用，用于身份验证。 JWT 数据分为三部分：头部，有效载荷，签名。通过base64UrlEncode函数将三者隔开来 主要攻击技术 敏感信息泄漏，有效载荷时明文形式传输，因此，有效载荷中存在敏感信息，就会泄漏 将签名算法改为 none。系统就会删除相应的签名数据 将 RS256 算法改为 HS256（非对称密码算法-&gt;对称密码算法） 破解HS256密钥 蜜罐调研与内网安全(https://xz.aliyun.com/t/7294) 蜜罐系统通过在网络中部署感应节点，实时感知周边网络环境，同时将感应节点日志实时存储、可视化分析，实现威胁情况感知。 一个好的蜜罐：能模拟大多数常见协议、能够模拟影响面广泛的应用协议和漏洞、能够在TCP/UDP端口捕获未知的恶意扫描、蜜罐便于协议扩展、蜜罐结果的数据格式简单便于分析 web蜜罐、服务蜜罐、其他蜜罐 logstash 日志解析，elasticsearch 日志存储、分析，kibana 可视化 自监督图神经网络(https://www.anquanke.com/post/id/217522) 实际中大多数数据并不是如图像与自然语言一样的数据具有高度结构化与顺序化的。人际关系、社交网络、蛋白质分子结构等等，这些数据往往都具有一对多、多对一、非结构化等特性，无法使用矩阵完美表示，然而这些数据可以用图的形式进行精确表达。 将深度学习的技术与思想应用于图数据结构之上催生了图神经网络。图神经网络可以捕获节点之间依赖关系，根据节点自身以及其周围邻域节点的信息建立状态的内部表示，以此获得比神经网络更为强大的表示能力。 GRAPH-BERT 从对老漏洞的分析谈二进制漏洞入门(https://www.freebuf.com/vuls/248394.html) 所需要具备的知识，一方面逆向分析（汇编语言、动态调试、静态分析）、代码审计。另一方面，多思考，多分享 漏洞背景：tcpdump4.5.1版本爆出拒绝服务漏洞。漏洞产生的原因是在函数hex_and_anscii_print_with_offset()没有对无符号型变量caplength进行检查，导致在运算过程中，整数溢出，内存访问越界。 通过不停的函数回溯进行分析，找到程序崩溃的原因以及地址所代表的意义，对于简单的漏洞，分析的综合能力不用那么强，padding 不是一定的。介绍了完整的漏洞分析场景，值得一读。 leetcode-twosun Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1]. 很简单的题目，主要题解分为循环以及 hashmap 两种思想都可。 ```def twoSum(nums, target):hashmap = {}for i, num in enumerate(nums): if hashmap.get(target - num) is not None: return [i, hashmap.get(target - num)] hashmap[num] = iif name == “main“:nums = [2,7,9,11]target = 9print(twoSum(nums, target)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384##### 9月19日 （天气☀️，心情累💢）- 一双vans、一顿饭、AirPods，心情瞬间变好了。果然花钱是让心情变好的最简单方式～###### 发现内网存活主机的各种姿势（一）- namp 命令行 - -sU 基于 UDP 的扫描 - -T5 namp的扫描速度 -T(0-5) 越大越快 - -sV 探测开启的端口来获取服务、版本信息 - -sn 不扫描端口，只扫描主机 -PR ARP ping扫描 -sP Ping扫描 sn -P0 无Ping扫描 -PS TCP SYN Ping扫描 -PA TCP ACK Ping扫描 -PU UDP ping扫描 -PE/PM/PP ICMP Ping Types扫描9月20日 （天气🌧️，心情愉悦✨）###### CTF特训营（211-269）- chrome 中的 F12 中 sources 通常用于下断点调试，Application 记录网站加载的所有资源信息，包括存储数据（Local Storage、Session Storage、cookie）、缓存数据、字体、图片，security从技术层面判断当前网页是否安全，不能判断内容上的，只能判断是否代码可疑、证书是否合法- SQL 注入成因，在开发过程中，将 URL 中的参数、HTTP Body 中的 Post 参数或其他外来用户输入与 SQL 语句进行拼接，造成语句可控从而达到任意执行。- 可回显得注入（联合查询的注入、报错注入、通过注入的DNS请求，从而达到可回显）、不可回显注入（Bool盲注、时间盲注）、二次注入- 有两种广泛使用 的x64 ABI - Microsoft‘s x64 ABI:前4个参数通过寄存器 RCX、RDX、R8、R9传递，其余则是通过栈传递，但在栈上会预留 0x20 字节的空间用于临时保存前 4 个参数，返回值 RAX - RAX func(RCX, RDX, R8, R9, [rsp+0x20], [rsp+0x28], ...... ) - SysV x64 ABI:前 6 个参数（RDI、RSI、 RDX、RCX、R8、R9、[RSP+8]、[RSP+0x10], ......）- IDA 使用 FLIRT 签名库的方式来识别函数，因此即使没有带符号信息的二进制程序，也可能识别库函数。对于不能识别的函数函数名会以sub_开头，后面再加入函数的起始地址。- 常见算法逆向 - base64 ：如果有见到索引表 ‘ABCDEFGHIJKLMN等等’基本就是确定了 base64 - TEA：对 TEA 的识别也比较容易，在 TEA 算法中有一个固定的常数 0x9e3779b9 或者 0x61c88647 - AES：主要是寻找 S 盒和逆 S 盒 - RC4: 主要是寻找初始化代码 - MD5: 会初始化四个称作 MD5 的链接变量的整数参数，因此看见0x67452301、0xefcdab89、0x98badcfe、0x10325476###### [2. Add Two Numbers](https://leetcode-cn.com/problems/add-two-numbers/)&gt; You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&gt;&gt; You may assume the two numbers do not contain any leading zero, except the number 0 itself.&gt;&gt; Example:&gt;&gt; Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807.- 基础数据结构题，没有什么大的难度，主要是细节考虑到位就行- ``` def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: • result = p = ListNode(None) • flag = 0 • while l1 or l2 or flag: • flag = flag + (l1.val if l1 else 0) + (l2.val if l2 else 0) • p.next = ListNode(flag%10) • p = p.next • flag = flag // 10 • l1 = l1.next if l1 else None • l2 = l2.next if l2 else None • return result.next 红队安全研发系列之免杀原理和绕过研究——静态查杀实现与绕过（https://www.anquanke.com/post/id/217531） 特征码和启发式查杀在免杀制作过程中，需要注意启发式查杀对壳一类的查杀非常厉害。 特征码查杀绕过可以通过对文件反复加密，加密方式可以自选，之后内存解密加载即可。 注意：这里仅仅是绕过静态特征码查杀，内存加载后被动态查杀。对于 Xor 和 base64 等加密后特征一致的算法需要多次加密。 启发式查杀，主要通过模仿正常 PE 特征。 Glibc 内存管理 .bss 段与堆栈之间的空间是空闲的，空闲空间被分成两个部分，一部分是 heap，一部分是 mmap 映射区域。Heap 和 mmap 区域都可以供用户自由使用，在向内核请求分配空间之前，对这个空间的访问会导致 segmentation fault。 内存管理风格 C 风格的内存管理程序主要实现 malloc() 和 free() 函数，内存管理程序主要通过调用 brk() 或者 mmap() 添加额外虚拟内存。 池式内存管理，内存池是一种半内存管理方法。内存池帮助某些程序进行自动内存管理，这些程序会经历一些特定的阶段，而且每个阶段中都有分配给进程的特定阶段的内存。例如apache 引用计数，所有共享的数据结构都有一个域来包含当前活动“引用”结构的次数。例如 Java 垃圾收集，全自动检测并移除不再使用的对象，通常会在可用内存少于一个具体的阈值时候运行。为了有效地管理内存，很多类型的垃圾收集器都需要知道数据结构内部指针的规划，所以，为了正确运行垃圾收集器，它们必须是语言本身的一部分。 12-13 讨论各种 C 内存管理程序，可以多看看 在 SMP 多线程环境下，对主分配区锁争用激烈，于是增加了非主分配区（non main arena），主分配区域与非主分配区用环形链表管理。每一个分配区有互斥锁。 malloced chunk A 表示是否是主分配区还是非主分配区，M表示是从 mmap 区域还是 heap 区域分配的，P 表示前面一个 chunk 是否在使用。p 为 0 时 prev_size 才有用 free chunk Bins 。用户free掉的内存并不马上归还给系统，ptmalloc 会统一管理 heap 和 mmap映射区域的空闲的 chunk，ptmalloc 将相似大小的 chunk 用双向链表连接起来，一个链表被称为一个 bin。1 个 unsorted bin，2-64 small bins，同一 small bin 中的 chunk 具有相同的大小，两个相邻的 small bins 相差 8 bytes。 9月21号（天气☔️，心情良） CTF特训营(268-) IDAPython、Angr 花指令 Linux常见反调试方法 利用 ptrace，Linux 下的调试主要是通过 ptrace 系统调用实现，一个进程只能被一个程序跟踪，所以如果程序被跟踪之后再来调用 ptrace 自然不会成功 proc 文件系统检测，读取 /proc/self 目录下的部分文件，根据程序在调试和非调试状态下的区别来进行反调试。 通过 getppid 系统调用获取得到程序的父进程，如果父进程是 gdb、strace 或者 ltrace ，则可以证明程序正在被调试。 针对以上的方法反调试方法。常用的方法就是定位到反调试的代码，然后 patch 加壳，加壳的程序真正的代码是加密存放在二进制文件中的，只有在执行时才从内存中解密还原出来，因此没法对加壳后的程序直接进行静态分析。 控制流混淆，对于控制流混淆的程序通常采用 trace 的方法。通过 Trace 工具记录下程序运行的所有指令，然后在运行这些指令的基础上进行数据流分析。 双进程保护，Debug Blocker。是一种在调试模式下运行自身程序的方法。这种保护通常存在两个进程，两个进程是调试器与被调试器的关系。由于真正的功能通常位于子进程中，所以要调试子进程，就必须先断开与已有调试器的链接。 虚拟机保护，将代码翻译为机器和人都无法识别的一串伪代码字节流，在具体执行时再对这些伪代码进行逐一翻译、解释。用于翻译伪代码并具体执行的子程序称为虚拟机。对于一个虚拟机而言它定义了一套自己的指令集架构（ISA），包括寄存器集、内存和指令集。 C# Java 等解释型语言编译后会变成字节码，幸运的是，大多数字节码与源码存在对应关系，保留了很多信息，例如函数名、变量名。 3. Longest Substring Without Repeating Characters难度中等 Given a string s, find the length of the longest substring without repeating characters. Example 1: 123Input: s = &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: s = &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: s = &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3.Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 123456789101112131415class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: ans = '' tep = '' for i in s: if i not in tep: tep += i else: tep = tep[tep.index(i) + 1:] tep += i if len(tep) &gt; len(ans): ans = tep return len(ans) 红蓝对抗中的近源渗透 蓝军是攻击方，红军是防守方 近源渗透定义为“指测试人员靠近或位于测试目标建筑内部，利用各类无线通信技术、物理接口和智能设备进行渗透测试的方法总称”。 正确的上网方式：软路由入门指南 “软路由”是特指将x86 PC或服务器通过特定软件实现路由功能。但本文的内容广泛一点。为了便于表达，我们暂且把所有可以运行自定义系统的路由器称为软路由吧。可以自行安装OpenWRT、DD-WRT的设备，我们都称为软路由。 提起这个，您的第一反应可能是TP-Link、腾达、水星等品牌的家用路由器。它们有一个特点：路由器的系统是由厂商基于Vxworks等系统，自行开发的嵌入式系统。一般来说，只能使用原厂的系统，而且功能不多。腾达的路由，要刷个水星的系统，是不可能的。 有这么一类操作系统，由社区开发维护，支持多种硬件平台。这些系统上的应用程序也可以算跨平台使用，而且应用程序非常丰富。著名的软路由系统有OpenWRT、潘多拉、梅林（午餐肉）、DD-WRT、Tomato，还有国内较为著名的iKuai等。 刷机的方法，一言蔽之就是通过漏洞获得路由器 Root shell，然后解锁 Bootloader 区并且刷入。 9 月 28 日（天气阴，心情好）从0开始聊聊自动化静态代码审计工具 自动化代码审计重点在于漏报率与误报率 动态代码审计工具（IAST），最常见的方法 Hook 恶意函数或是 api 并通过前端爬虫判别是否触发恶意函数来确实漏洞。 IAST 优点在于误报率比较低，缺点（1）爬虫难以保证对代码功能的覆盖率（2）对底层以及 hook 策略依赖较强（3）对环境的强依赖、对执行效率的需求、难以和业务代码结合 SAST-静态代码审计工具，最早期通过关键词正则匹配，一种高覆盖性-宁错杀不放过，典型 Seay，一种高可用性-宁放过不错杀，典型 Rips 近代时期-基于 AST 的代码分析，关键词匹配因为代码开发人员的自由性而不能非常准确，代码不同但是编译器相同，语义分析库如下 https://github.com/nikic/PHP-Parser https://github.com/viraptor/phply 基于 IR/CFG 带有控制流的解决方案是更为主流的，因为 AST 更接近脑中的执行流程， 10月9日 （天气🌧️，心情愉悦✨） 美国网络风暴演习系列活动对我国网络安全工作的启示 协调联动在应急响应中发挥着重要作用 信息共享极为关键，对应急响应效果作用明显 流程机制的完善与迭代是协同防御的重点 等保测评师角度浅谈等保2.0 标准体系制定过程中受安全产品厂家影响较大 标准制定水平较1.0差，重复检验太多、对应测评对象无法测评、缺少可操作性和实践性 10月12号（天气☔️，心情良）leetcode 双指针以及空间保存临时状态是非常经典的方法 基础还是需要打牢 10月27号（天气🌞，心情良）八大看点丨个人信息保护法草案如何捍卫个人信息安全 适用范围更清晰 职责分工更明确 处理个人信息要先取得用户同意 处理敏感信息限制更加严格 突发公共卫生事件中个人信息保护 强化个人信息保护责任和义务 情节严重违法行为处罚可达 5000万 Gartner2020年十大安全项目详解 远程员工安全（零信任网络访问技术） 基于风险的弱点管理 基于平台方式的检测与响应，特指扩展检测与响应（XDR） 云安全配置管理 简化云访问控制，特指云访问安全代理（CASB）技术 基于 DMARC 协议的邮件安全防护 无口令认证 数据分类与保护 员工胜任力评估 安全风险评估与自动化","link":"/2020/09/17/everyday_read/"},{"title":"每日记录","text":"记录每天的收获与总结 2019-08-05 最近确实被保研的事儿弄的有点烦心，但是感觉也算是对自己的一种锻炼吧。事实也告诉我，投机的人确实有，但是真正踏实的师傅总会有所收获。在华为实习已经一个月了，也算是有所收获，本来就是抱着看看工业界的安全是什么样子的想法，能多学点就多学点的态度，总归来说还是不错的。慢慢的从刚来实习时完全不适应的状态（确实和上学差别太大，加上深圳这边天气闷热），到慢慢有了自己的生活节奏，感谢 Bilibili（学习网站）的一些学习 UP 主，让我在工作之余还能有学习状态。 目前主要还是自己内心的一些学习方向的挣扎，确实也体会到了一个人的精力是有限的，不可能面面俱到。不得不说人与人之间的差距真的很大，有些师傅很浮躁，有些师傅就很踏实。希望自己可以不断像踏实的师傅（武师傅、马哥、fish、pupil等）学习。我也希望可以找到自己真正的兴趣，尝试去融入到生活与工作之中。 今天主要还是在学习 Go 语言方面的基础，背了一个 Unit 的英语单词，看了一节日语课。学习了一位很强的师傅挖 CVE 的思路，希望自己多多加油，拿到一个有份量的 CVE。 2019-08-06 从小到大，第一次落枕，太痛苦了。早上起来听到脖子“咔”的一声，瞬间脖子就动不了了，一发力就痛。还得去公司，着实有点痛苦，导致我一天都不在状态，所以说还是要多注意身体，身体不行的话真的干什么都不行。 最近对于实习的任务感觉到不少疑惑，有点怕打扰别人，又十分困惑，还是得多多交流，找回状态。 最近跟着 Bilibili 的一些 UP 主，真是帮助我找回了学习的节奏，真是非常感谢。 2019-08-07 不得不吐槽一下，公司的打卡制度，我回到家里才想起来，好像忘打卡了，导致我又得回去再打一次，有点难受。 每天保持锻炼习惯也有一阵子了，确实效果很不错，整个人锻炼完后就有一种清爽的感觉。 和老妈视频，她觉得我和她联系的太少了。主要我又是一个比较独立的人，遇到什么事情都是自己解决。从事的也不是同一个领域的工作，导致可能确实没什么交流。但是可能还是要多和老妈找找话聊，感觉她感觉好像帮不上我什么忙，很失落。 2019-09-23 好长时间没有记录了，这段时间也是一直在忙自己升学的事情，终于也算有了一个结果。不用在为上学的事情在烦恼了，这种感觉挺好的。每天可以学自己的东西了，希望自己在未来的日子，接着加油吧。 美团面试完后，感觉三面聊的不太好，但是好像最后也还是过了。也算是多了一种选择，看自己的想法了。 最近可以接着学习日语了，以及把服务器好好弄弄。加油吧！ 2021-5-26 在科研的过程中，不要将目标和方法都限制死，要敢于去质疑当前的模型 -李辉老师 论文产出的三要素：学生感兴趣、老师感兴趣、学术界感兴趣 -The Phd Grind 人生不可控、不坚持就不会成功 -The Phd Grind 2021-7-18 对最新文献进行跟踪、文献报告 对某一具体领域的研究、专题报告 一篇文章写好后总结对于这个领域的贡献是什么，解决了什么问题，按照重要性顺序写下来——contribution 比较别人论文优缺点——related work 概括问题与解决方案、可以通过例子——Overview 指出问题很重要，*** insight *** 2021-7-20 针对微博图床加载不了图片的问题，可以在 themes/xxxx/layout/_partials/head.swig 中添加解决 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 这样微博检查不到是否为外链 2021-9-14 德发兴味道确实不错 整体第一天实行计划感觉还是不错的，状态各方面还是不错的 2021-9-15 篮球水平感觉有点陷入舒适区了，应该多多尝试不习惯的打法 今天阅读论文可以找人交流一下 2021-9-16 健身小练😊","link":"/2019/07/08/daily/"},{"title":"Paper 阅读","text":"Everything from paper 论文阅读USENIX SUPOR: Precise and Scalable Sensitive User Input Detection for Android Appsabstract 主要描述做了一个工具 SUPOR，一个对于用户输入的静态检测工具。 Introduction 之前的研究主要集中于智能手机中被操作系统以及架构 API 所管理涉及的隐私信息。忽略了用户的输入，现在很多 app 要求用户输入各种，所以对于用户的输入不能忽视。 主要的识别隐私用户输入的挑战 如何系统识别用户的输入域在 app 的 UI 中 如何识别哪些输入域是敏感的 如何将敏感输入字段与存储他们 value 的应用程序中的变量相关联 分析 UI 隐私分析输入区域通过利用UI渲染，几何布局分析和NLP技术。 ~问：关于这个输入点这个地方，他假设说的是用 HTTP 明文传输。我就在想如果输入点输入的东西用 HTTPS 或者加密了的话，这个寻找输入点是不是没有意义呀～ An Empirical Evaluation of GDPR Compliance Violations in Android mHealth Apps GDPR 三种违规行为 隐私策略不完整 数据收集的不一致 数据传输的不安全 一个是 privacy policy 完整情况，一个是数据的收集范围，一个是传输方式的安全性 对于 GDPR 的对照检测只是做到了基本要求，还有其他可以检测的地方 NLP 技术使用一般，但是他有隐私政策语料库 技术大杂烩的感觉，不过整体方案挺完整的感觉 Polisis: Automated Analysis and Presentation of Privacy Policies Using Deep Learning 整体实现了一个隐私政策查询系统以及一个问答系统，缺乏可用的、可扩展的工具来处理隐私策略的广度和深度 privacy icons 分层次架构 KnIGHT: Mapping Privacy Policies to GDPR 自动对应 privacy policies 与 GDPR，看他符合哪一个片段。 里面有一些工具可以用 学术规范与论文 数学非常重要、研究兴趣、积累论文（数量、质量） 论文精读要达到抛开论文能自己完成所有的推导，自主完成复现，最少 5 遍以上 确定具体研究点、研究的持续性、给予足够重视、积极参与学术活动 标题 反映核心技术 尽量精炼简洁 摘要 标题的扩充 覆盖亮点、出发点、效果 引言 摘要的扩充 研究背景 提出问题及原因 文献调研 本文贡献 参考文献 作者、标题、刊物/会议名称、卷号、页数、月份、年份 不同领域对于参考文献的要求不同 复稿——10遍左右 第二遍细改，理清思路 第三遍速读，调整逻辑 与审稿人打交道 批判接受意见 心存感激 学会忍耐 逻辑、语言、数学（GRE 内容） 一定要主动找老师 实验过程-&gt;结果与讨论-&gt;结论-&gt;引言 返修，按审稿人的问题逐条回复。列出改动的地方，并在正文中标记 GDPR 与 个人信息保护法 对比 目录 GDPR 个人信息保护法 一般规定 总则 原则 一般规定 数据主体的权利 敏感个人信息的处理规则 控制者和处理者 国家机关处理个人信息 个人数据转移 个人信息跨境 独立监督机构 个人信息处理活动的权利 合作和一致性 个人信息处理者的义务 责任和处罚 个人信息保护职责的部分 有关特定加工情况的规定 法律责任 委派行为和执法行为 附则 最后条款 个人数据定义相似，已识别或可识别的自然人有关的各种信息。其中草案定义不包括匿名化的信息。 “处理”的定义，GDPR 定义为对个人数据或个人数据集执行的任何操作或一组操作。草案没有明确定义只是列举了几个操作。 敏感个人数据定义有所不同 GDPR 将敏感个人数据定义为 “特殊类别的个人数据”。种族或民族出身、政治观点、宗教或哲学信仰（或信仰缺失）、工会会员资格、健康，性生活、性取向、生物特征。 一旦泄露或者非法使用，可能导致个人受到歧视或者人身财产安全受到严重危害的个人信息，包括种族、民族、宗教信仰、个人生物特征、医疗健康、金融账户、个人行踪 数据保护原则 GDPR：合法公正透明、目的限制、数据最小化、准确性、存储/保留限制、完整性和保密性 草案：合法公正透明、目的限制、数据最小化、准确性、完整性和保密性 个人主体权利来说，GDPR覆盖面大于草案 GDPR：访问权、纠正权、删除权（被遗忘的权利）、限制处理权、被通知权、携带权、数据可携带权、反对权 草案：访问权、纠正权、删除权、被通知权 自动化决策 整体来说，草案在严谨性以及覆盖面不及 GDPR 个人信息保护法自动化分析小demo 隐私策略的完整性 数据收集的一致性 创新点：删除权 Advances and Open Problems in Federated Learning Achieving Security and Privacy in Federated Learning Systems: Survey, Research Challenges and Future Directions3.1 Byzantine attacks 拜占庭一般问题，指的是分布式系统达成共识中的问题，不一定是恶意的 更新聚合中，加权和平均很容易受到拜占庭攻击 3.2 Model poisoning attacks 与拜占庭相反，攻击者不阻止模型收敛，对手使用的任何攻击策略都必须确保全局模型收敛到在测试集上具有良好性能的点。 防御机制 Detection of malicious clients via model metrics，即根据比较准确率等一系列指标判断，是否让节点参与训练，此时服务器要能够接触数据集 Detecition of malicious clients via update statistics，即根据更新指标判断，超出特定范围的距离的更新将被视为异常更新 Krum aggregation rule，该方法答题思路就是选取方向大致相同的节点进行更新 Coordinate-wise median，中位数更新，中位数是比均值更稳健的统计量（即，它受异常值的影响较小），因此获得的全局模型受潜在恶意对等点的影响较小。 Coordinate-wise trimmed mean，对于均值进行修剪使用 4.Privacy attacks and defenses Honest-but-curious FL server.认真完成聚合，但是会推断相关信息 Malicious FL server.不一定完成聚合工作，还会实行攻击 Honest-but-curious client.可以观察全局参数，去推断别的节点隐私信息 Malicious client.实行攻击的节点 攻击方式 inference attack，推断攻击的范围还是非常广的，方法也有很多 Client-side GAN-based attacks，记录级的 DP 无法防御，生成同样分布的样本。局限性： 分布式架构的改变来引入对抗性影响 多次迭代后，攻击效果可能减弱 攻击只能模仿用于训练的输入数据，而不是来自受害者的确切样本 FL server-side GAN-based attacks，不影响学习过程，影响协作学习过程和不修改共享模型的情况下提高了生成样本的质量，从而实现了隐形攻击。FL 服务器能够区分客户端的身份这一事实能够实现客户端级别的私有数据检索。 抵抗方式 安全多方计算（SMC）：无损、通信成本大、由于不暴露个体参数梯度信息以至于一些类似于krum就无法实施。安全多方计算阻止服务端了解聚合过程中的信息，但是投毒攻击与拜占庭攻击都需要通过服务端分析各个节点的信息，导致之间相互冲突 差分隐私（DP）：有损、使用比较多 DBA: D ISTRIBUTED BACKDOOR ATTACKS AGAINST FEDERATED L EARNING 提出了一种分布式的后门攻击，利用联邦学习的分布式特性。我们在FL 上提出了一种新颖的分布式后门攻击策略DBA，并表明DBA 比集中式后门攻击更持久和有效。基于广泛的实验，我们报告了一个突出的现象，即尽管每个敌手仅通过 DBA 植入了局部触发模式，但与集中式攻击相比，他们组装的模式（即全局触发）在全局模型上获得了显着更好的攻击性能。结果在不同的数据集和不同的攻击场景下是一致的，例如一次性（单次）和连续（多次）中毒设置。据我们所知，本文是研究分布式后门攻击的第一部作品。 Attacker ability：基于 Kerckhoffs 的理论 (Shannon, 1949)，我们考虑这里的强大攻击者，他们完全控制了他们的本地训练过程，例如后门数据注入和更新本地训练超参数 。 这种情况非常实用，因为每个本地数据集通常由本地一方拥有。 然而，攻击者没有能力影响中央服务器的特权，例如改变聚合规则，也不能篡改其他方的训练过程和模型更新。 Objective of backdoor attack：后门攻击旨在误导训练有素的模型在嵌入了攻击者选择的模式（即触发器）的任何输入数据上预测目标标签 τ。 与拜占庭式攻击（Blanchard et al., 2017）不同，后门攻击的目的是操纵局部模型并同时拟合主任务和后门任务，从而使全局模型在 未篡改的数据样本，同时对后门数据样本实现高攻击成功率。 Factors in distributed backdoor attack Trigger size、Trigger gap（距离）、Trigger location、Scale（类似学习率）、Poison ratio（中毒样本比例）、Poison interval（两次中毒之间的间隔）、Data distribution Distributed backdoor attack v.s. centralized backdoor attack 分为两种攻击场景，A-M 和 A-S 即多轮攻击与单轮攻击，Attack A-M 研究成功注入后门的难易程度，而 Attack A-S 研究后门效应减弱的速度 The Robustness of distributed attackBackdoor Attacks and Countermeasures on Deep Learning: A Comprehensive ReviewAbstract 强调了后门攻击的新颖性，提出了本综述的意义 Firstly，针对攻击者能力没有系统分类 Secondly，针对防御方法缺少系统分析与比较 攻击分成 6 类， code poisoning、outsourcing、pertained、data collection、collaborative learning、post-deployment 防御分成 4 类，blind backdoor removal, offline backdoor inspection, online backdoor inspection, and post backdoor removal 后门攻击的另一面：保护深度学习模型的知识产权，充当蜜罐以捕获对抗性示例攻击，以及验证数据贡献者请求的数据删除 A TAXONOMY OF ADVERSARIAL ATTACKS ON DEEP LEARNING DL 容易遭受对抗性攻击，因为黑盒、模型的复杂性、决策的缺乏可解释性 后门攻击是针对深度学习的一种对抗性攻击。 它区别于对抗样本、通用对抗补丁（通用对抗样本/扰动 和数据中毒。 对抗性示例和通用对抗性补丁是规避攻击，仅影响模型部署后的推理阶段。 数据中毒是在数据收集或准备阶段进行的。 然而，后门攻击可以在 ML 管道的每个阶段进行，除了模型测试阶段以保持沉默。 后门攻击相较于对抗性样本更加灵活，可以布局于不同的阶段 UAP 是更加复杂多样的对抗样本，可以视为“幽灵”后门，幽灵的解释是它是深度学习的内在属性，但依然有区别 trigger 是任意的，而精心设计的 UAP 不是任意的。因此，触发器处于攻击者的完全控制之下，而 UAP 则取决于模型 通过后门触发器的攻击成功率通常远高于UAP，尤其是在攻击者更喜欢有针对性的攻击时 数据中毒攻击，降低模型准确性，且无目标，但后门攻击保留了其主要任务的良性样本的推理准确性，并且只有在存在秘密触发器的情况下才会偷偷地进行不当行为，后门攻击通常作为有针对性的攻击来执行——触发器输入被错误地分类为攻击者的目标类别 后门模型学习攻击者选择的子任务和（良性）主要任务的一种方式。 一方面，对于不包含触发器的输入，后门模型通常表现为其干净的对应模型，因此无法仅通过使用测试样本检查测试准确性来区分后门模型和干净模型。 这与上面的中毒攻击不同，它恶化了主要任务的整体准确性，因此引人注目（和可疑）。 另一方面，一旦输入中出现秘密触发器，后门模型就会被误导以执行攻击者的子任务，例如，即使与输入的原始内容无关。 BackgroundA. Attack Surface code poisoning：使用第三方库从而导致的代码层面攻击 outsourcing(外包)：恶意 MLaaS 提供商控制训练阶段并在训练过程中对 ML 模型进行后门处理。 pertrained:当重复使用预训练模型或“教师”模型时，会引入此攻击面 data collection:数据收集通常容易出错并且容易受到不可信来源的影响 collaborative learning:作学习容易受到各种攻击 ，包括后门攻击。当极少数参与者受到攻击者的危害或控制时，联合学习的模型很容易被后门。如果使用参数加密技术是无法检查数据或者模型的 post-deployment:ML 模型已经部署，特别是在推理阶段，考虑一个典型的攻击场景，其中攻击者和用户是共享同一服务器的两个进程。 用户启动 ML 模型并将 ML 权重加载到内存中。 攻击者通过触发 rowhammer 错误 [80] 间接翻转权重的位 B. Backdoor Variants Class-specific and class-agnostic：后门攻击一般是有目标的🤔，后门攻击可以分为类不可知（当触发效果独立于源类时）和特定于类的攻击（当触发效果依赖于源类时）。对于前者，后门模型可以将来自任何带有触发器标记的类的输入错误地分类为目标类。也就是说，触发器的存在主要决定了攻击。至于后者，后门模型可能会将来自带有触发器标记的特定类的输入错误分类为目标类。也就是说，触发器的存在以及特定的类决定了攻击。 Multiple tirggers to same label：多个触发器对应一个标签，多个触发器中任何一个触发器的存在都可以将后门模型劫持到相同的目标标签 Multiple Triggers to Multiple Labels：在这种情况下，后门模型可以被多个触发器劫持；但是，每个触发器针对不同的标签 C. Backdoor Preliminary Clean Data Accuracy(CDA)：不含触发器的干净测试样本，这些样本被正确预测到它们的真实类别的比例 Attack Success Rate(ASR)：包含触发器的干净测试样本，这些样本被预测到攻击目标标签的比例 Backdoor AttacksA. Outsourcing Attack Invisible Trigger：我们注意到隐形导致触发器更像是添加的噪音。在很大程度上，对抗样本的防御可以应用于防御这种隐形后门攻击。有几种有效的对抗性示例对策，例如特征压缩 、输入转换 、降噪，可用于击败此类隐形触发攻击。 Backdoor Reinforcement Learning：后门顺序模型，一个区别是触发器的呈现方式和后门行为的激活方式。在以前的后门分类任务中，后门效应在触发器出现时立即激活，一旦没有触发器就消失。相比之下，杨等人。 证明动作可以与后门顺序模型中触发器的存在不同步——对抗性动作可以是几个步骤之后。此外，触发器只出现很短的一段时间——例如，在特定的步骤，但如果触发器消失，后门行为将继续。这两个属性可能会使触发器检测更加艰巨，因为即使确实注意到了对抗性动作，也无法将触发器与对抗性动作联系起来 总结：外包增强了攻击者能力，他可以接触训练数据和模型，控制 trigger 和训练过程，值得一提的是，攻击者始终可以将防御目标的规避纳入损失函数，以自适应地绕过现有的对策 B. Pretrained Attack 用户的数据或/和计算资源很少，无法训练准确的模型。 因此，用户将使用公共或第三方预训练模型来提取一般特征。 Trojan Attack：严格来说，这种攻击并没有专门针对受害者训练学生模型的迁移学习——在某种程度上，属于外包攻击面。它利用已发布的模型来加速后门过程，并期望受害者直接使用重新分发的后门模型。尽管如此，结果表明，如果后来的受害者确实采用这种后门模型进行迁移学习，触发输入的模型准确性将在一定程度上降低——扰乱其正确行为。然而，由于攻击者不知道新任务的输出标签，触发器输入无法将新模型误导到目标标签。 Model Reuse Attack：攻击者确实需要知道下游任务和用户使用的小数据集。与任何带有触发器标记的输入都会被错误分类的传统后门攻击相比，模型重用攻击似乎仅适用于有限的对抗性输入 Programmable Backdoor Latent backdoor：思路大概是攻击未来的标签，攻击感染预训练的教师模型。通常，潜在后门是注入教师模型的“不完整”后门——攻击者目标标签 尚不存在于教师模型中。但是，如果任何学生模型包含，则迁移学习过程会自动完成后门并使其处于活动状态。 Appending backdoor：总的来说，它通过将另一个单独的后门（小）神经网络与目标模型附加或合并来实现。 因此，它不会篡改目标模型的参数。 作为权衡，这项工作必须改变模型架构。 在实践中，架构变化并不隐蔽。 因此，只需检查模型架构规范即可轻松检测到 GNN backdoor 总结：然而，攻击者无法控制下游任务和用户采用的迁移学习策略。 ASR 通常不如外包后门攻击高。 至于潜在的后门 ，ASR 很容易被破坏。 值得一提的是，预训练后门攻击或多或少假设了下游任务的特定知识（可能是推测的）和下游任务的一小部分数据 C. Data collection attack 需要中毒数据更加隐蔽，特别是为了欺骗人类检查。 然而，攻击者无法控制和操纵训练过程或最终模型 Clean-Label Attack（怎么感觉和对抗样本有点像🤔）：保留中毒数据的标签，看起来仍是一个良性样本。对于清洁标签攻击，我们注意到触发器是一组特定的（测试）图像样本，而不是通用的特定模式。换句话说，后门攻击仅适用于一个或一小组输入——注意预训练下的模型重用攻击实现了类似的后门效果。这种隐藏的后门攻击似乎更实用和更强大，因为可见的推理触发器仅在攻击出现时才会显示，但在数据中毒期间通过不可见的中毒触发器隐藏。这些清洁标签攻击假设受害者了解模型 Targeted class data poisoning：数据中毒引入的传统后门，它随机 i) 从不同的源类别中选取训练样本，ii) 标记触发器，以及 iii) 将它们的标签修改为目标类别。提出了基于 GAN 和对抗性扰动来注入后门。为了对 ASR 有效，攻击者需要对模型架构和后期训练过程有充分的了解 Image-Scaling Attack：这滥用了人类（篡改的“羊”形象）和机器（“狼”形象）之间对同一形象的不一致理解。因此，可以有效且隐蔽地利用缩放伪装在黑盒设置下执行后门攻击；一般来说，触发图像可以伪装成目标类别的图像，通过执行图像缩放攻击来毒化训练数据，从而对训练模型进行后门处理。在推理阶段，触发器现在可以轻松激活后门模型，而无需使用缩放攻击。 总结：对于中毒的数据，由于其内容始终与标签一致，因此在进行人工或目视检查时很难区分。 因此，不仅端到端训练的模型而且迁移学习都可能受到感染。 特征冲突是制作标签一致的有毒输入以注入后门的常用方法。 但是，在某些情况下，需要了解受感染模型架构的一些知识才能确定适当的潜在表示 D. Collaborative learning attack 结果表明，即使仅在一轮（单次攻击）中选择单个客户端为联合模型更新做出贡献，联合模型在插入后门后立即具有 100% 的 ASR。随着联合模型继续学习，ASR 确实会减少。通过控制不超过 1% 的客户端，联合模型与干净模型的准确度相当，现在无法防止后门被遗忘。由于原则上不允许访问数据，因此要击败联邦学习的后门攻击非常具有挑战性。拜占庭弹性聚合策略对此类攻击无效。更糟糕的是，当采用安全聚合来进一步增强隐私时，防御会变得更加困难 总结：一方面，协作学习越来越被使用。 另一方面，由于很难控制恶意参与者提交的数据和本地模型，因此它天生容易受到后门攻击。 E. Post-Deployment Attack F. Code poisoning Backdoor countermeasuresA. Blind Backdoor Removal 不区分后门模型与干净模型，或从干净输入触发输入。 主要目的是消除或抑制后门效应，同时保持干净输入的 CDA，特别是考虑到它最终是一个干净的模型。 Fine-Pruning：修剪 DNN 模型中精心选择的对主要分类任务贡献最小的神经元来移除潜在的后门 。 更准确地说，神经元根据它们在干净输入（例如，保持验证样本）上的激活进行排序，并以最少激活的顺序进行修剪。 一种普遍的假设是，由清洁和触发输入激活的神经元是不同的或可分离的。 修剪后，微调用于恢复模型性能。 Februus：利用视觉解释工具来识别潜在的触发区域。 一旦确定该区域，Februus 将手术移除恶意区域并将其替换为中性灰色。 这种手术去除步骤已经消除了触发效应，并可能降低深度神经网络的分类。 提出了一个额外的步骤，即图像恢复，使用基于 GAN 的图像修复方法将受损区域恢复到被污染之前的原始可能性。 该方法对多个后门变体具有鲁棒性，尤其是针对特定类别的后门变体。 然而，由于该方法涉及删除和恢复图像，它对大尺寸敏感 Suppression：给定每个输入，制作了许多副本：每个副本都通过添加一些噪声而受到干扰——噪声水平是凭经验确定的。所有被扰动的副本都被输入到 DNN 模型中，无论是后门的还是干净的，以收集预测。 ConFoc：基本原理是图像由内容和样式信息组成[138]。前者是指物体的形状或语义信息，后者是指图像的颜色或纹理信息。据推测，在进行分类时，仅关注内容类似于人类的推理。因此，ConFoc 重新训练模型进行分类，主要依靠内容信息。 ConFoc 的一个主要限制是它假设触发器不与输入图像中感兴趣的对象（具有内容信息）重叠，这在设置触发器与对象重叠时不适用 RAB：尽管可证明的鲁棒性是可取的，但 RAB 有严格的条件，例如触发器扰动界限必须很小，这意味着只要触发器的扰动超过界限，它就可以在实践中轻松绕过。此外，还有许多“平滑”模型需要训练，这大大增加了计算开销。此外，为了保证可证明的鲁棒性，RAB 需要了解中毒数据的比例和扰动边界类型，例如 l2 范数，这往往是不切实际的。 B. Offline Inspection ​ 1）Data Inspection Spectral Signature：当干净输入的潜在表示与触发输入的潜在表示完全不同时，这种防御就会成功。因此，一个关键的步骤是确定获得适当潜在表征的方法，以暴露触发器的踪迹 。但是，它指出异常值比率固定为接近目标类中损坏样本的比率 Gradient Clustering：假设然后证明触发图像样本可能导致输入层在触发位置的梯度绝对值相对较大。 基于此，可以使用聚类算法将触发样本与干净样本分开。 由于作者可以检测受感染的目标和源类别，因此可以通过将触发样本重新标记为正确的标签来重新训练受感染的模型，以消除后门效应，而不是使用已删除损坏数据的净化数据从头开始训练模型。 Activation Clustering：最后一个隐藏层的激活反映了神经网络用于达到模型决策的高级特征。给定收集到的数据和用数据训练的模型，将每个样本输入模型，并收集相应的激活。通过在降维后应用 k = 2 的 k 均值聚类，将属于同一标签的输入的激活分离和聚类。由于 2-means 聚类总是将激活分成两个簇，无论是否存在中毒数据，都会使用一些度量来判断。例如，高剪影分数意味着该类已被感染或中毒。一旦识别出中毒数据，就可以将其删除，并训练一个干净的模型。 Deep KNN：设计一个深度 k-NN检测清洁标签中毒样本的方法，可以有效对抗特征碰撞和凸多面体清洁标签攻击 SCAn：攻击者目标类（受感染类）中图像的潜在表示是来自触发输入和干净输入的两组的混合。每个都被分解为不同的身份和通用变化组件。回想一下，触发图像来自不同的类别/身份，但（错误）标记到目标标签。以便可以识别受感染的类。 SCAn 还有一个额外的主要优势，它也适用于特定于类的触发器。作为一个轻微的矛盾，它最终假设一小组保持干净的验证集，必须不包含触发器，从这个数据收集表面下的内部收集。SCAn 对多目标触发攻击的效果较差。 DP：模型已经极大地抑制了后门效应——ASR 非常低。此外，模型在预测非典型中毒示例时的信心也会降低。因此，通过将损失作为度量来衡量，可以区分中毒输入，因为它具有更高的损失分数。 ​ 2）Model Inspection Trigger Reverse Engineer：NeuralCleanse 遍历模型的所有标签，并确定是否有任何标签需要更小的修改来实现错误分类。这种方法的一个优点是可以在后门模型检测过程中对触发器进行逆向工程和识别。一旦触发被识别，后门移除可以通过重新训练来消除触发效应。但 NeuralCleanse 仍然有一些限制。首先，它可能会产生与标签数量成正比的高计算成本。对于特定的 DNN 模型，即使考虑了优化，检测过程的计算成本也可能需要几天时间。当任务的类数很大时尤其如此。其次，与大多数后门对策一样，据报道，随着触发器大小的增加，该方法的效果较差。第三，它需要训练参考模型来确定一个（全局）阈值来区分干净模型和后门模型，这在外包下无意中似乎不适用。因为这违反了外包的动机，因为用户的计算资源或/和 ML 专业知识有限。 DeepInspect：DeepInspect 的关键思想是使用条件生成模型来学习潜在触发器的概率分布。 该生成模型将用于生成反向触发器，其扰动水平将被统计评估以构建后门异常检测。 AEGIS：将输入样本与其潜在表示进行聚类并不是什么新鲜事，它已被用于触发数据检查 。不同之处在于之前的工作需要访问中毒的触发数据，而 AEGIS 则不需要。 AEGIS 的局限性仅适用于稳健模型，不适用于标准模型。人们还承认，击败特定触发器，例如混合触发器，诱导后门似乎是 AEGIS 的一个挑战 Meta classify：它由防御者训练许多干净的和后门影子模型作为元分类器（另一个神经网络）的训练样本，以预测新模型是否干净。当数据集发生变化时，必须执行这种计算成本高的阴影模型训练。 总结：由于防守方的能力较差，尤其是由于无法访问中毒样本，因此离线模型检查通常需要高计算开销和 ML 专业知识也就不足为奇了。 在这种情况下，外包和预训练的防御者可能无法采取这些对策。 C. Online Inspection ​ 1）Data Inspection STRIP：一方面，对于干净的输入，预测 z 应该与真实情况大不相同，因为对其施加了强而有意的扰动。因此，具有不同扰动的干净输入的副本表现出很强的随机性——通过熵度量量化。另一方面，对于触发器输入，由于触发器的强劫持效应，即使在扰动下，预测 z通常也应该与攻击者的目标 保持恒定。因此，具有变化扰动的触发器输入的副本表现出弱随机性。给定一个预设的熵阈值——可以单独使用干净的输入来确定，触发输入（高熵）可以很容易地与干净的输入（低熵）区分开来。STRIP 的一个限制是它主要是为类不可知的触发器而设计的，而这些触发器对于类特定的触发器是无效的。 Epistemic classifier：它通常基于这样的假设，即具有触发器的输入可能从输入层中的源类开始接近干净的训练实例，但其在神经网络上的轨迹将缓慢或突然接近攻击者选择的目标类。 ​ 2）Model Inspection ABS：使用 ABS 检查单个神经元激活差异以检测后门异常，这可以潜在地击败对序列模型 超出分类任务的后门攻击。 ABS 的优势在于 i）它与触发器大小无关，并且 ii）每个标签只需要一个干净的训练输入来检测后门。 iii) 它还可以检测对特征空间而不是像素空间的后门攻击。然而，该方法似乎仅在某些关键假设下有效，例如，目标标签输出激活只需要由一个神经元激活，而不是由一组神经元的相互作用激活。因此，它可以通过使用中的扩展触发器轻松绕过。此外，范围也仅限于每个标签一个触发器的攻击。如果多个触发器旨在攻击同一个标签，那么 ABS 将无法实现。 NIC：这种方法通常可以被视为检查跨 DNN 层的激活分布和流（受编程中使用的控制流的启发），以确定是否由于对抗样本而违反了流。 总结：在线检查的一个优点是一些对策对触发大小不敏感。 此外，在线检查对策在某种程度上具有对不同领域的良好泛化。 一个限制是在线检查通常会导致延迟。 D. Post Backdoor Removal 一旦通过模型检查或数据检查检测到后门，就可以考虑删除后门。一种方法是删除损坏的输入并再次训练模型，这似乎仅在数据收集下才实用，因为不允许用户在其他攻击面下访问触发器输入。另一种方法是通过使用包含触发器但正确标记的损坏数据重新训练或微调后门模型，从模型中去除后门行为，重新学习更正的决策边界。 Flip Slide of Backdoor Attack watermarking：目前有一些作品将后门作为水印来保护受过训练的 DNN 模型的知识产权（IP）。论点是插入的后门可用于声明模型提供者的所有权，因为应该只有提供者知道这样的后门。相比之下，后门 DNN 模型在正常输入上没有（或察觉不到）功能性能下降。尽管有多种对抗后门插入的检测、恢复和移除对策，但我们推测使用后门技术的水印通常是稳健的。理由是开发一对多的后门对策非常具有挑战性。但是，我们建议始终考虑谨慎的后门插入策略来为模型添加水印，尤其是考虑到自适应后门插入。利用后门作为信息隐藏技术或速记技术是可行的。 against model extraction：当攻击者查询旨在窃取主任务功能的模型时，作为不同子任务的水印可能不会传播到被盗副本。 against adversarial examples：类似于蜜罐🍯 data deletion verification：验证用户删除，ASR 可以检查后门跟踪，如果数据删除得到遵守，后门跟踪应该非常低。因为现在应该在没有用户数据的情况下训练模型，也没有数据中包含的后门痕迹。 Discussion and prospect 自适应攻击 Backdoor Learning: A SurveyIntroduction 这篇文章中将防御方法分类成基于经验以及经过认证的两种，个人觉得没有上一篇根据防御者能力分类的效果好。 它主要分析三个场景 第三方数据源 第三方平台 第三方模型 Poisoning-based backdoor attacks NEURAL ATTENTION DISTILLATION: ERASING BACK - DOOR TRIGGERS FROM DEEP NEURAL NETWORKSAbstract NAD 利用教师网络指导后门学生网络在一个小的干净数据子集上的微调，使学生网络的中间层注意力与教师网络的中间层注意力保持一致。教师网络可以通过对同一个干净子集的独立微调过程获得。我们凭经验表明，针对 6 种最先进的后门攻击，NAD 可以仅使用 5% 的干净训练数据有效地消除后门触发器，而不会导致干净示例的明显性能下降。 Introduction attention maps 可以作为一种直观的方式来评估后门防御机制的性能，因为它们能够突出显示网络拓扑中的后门区域 knowledge distillation 知识较多的网络称为教师网络，较小的网络称为学生网络。 特征图和注意力机制已被证明在 KD 中非常有用，可以监督学生网络的训练。 Proposed approach NAD 与传统微调方法之间的差异。 我们没有将微调网络直接用作我们的最终模型，而是将其用作教师网络，并通过将其与原始后门网络（即学生网络）结合使用注意力蒸馏过程。","link":"/2019/07/08/paper/"},{"title":"leetcode recode","text":"三百六十五个日子里 leetcode_recode main programming language: C++ 1. Two SumEasy Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 分析： 我们可以建立一个 unorded_map 来存储数组里面每个值以及它所对应的位置关系。 我们用 other_num = target - nums[i]。然后如果不是重复元素，就去找是否存在，如果存在就直接压入 vector。如果是重复元素，就遍历整个 vector 来找到位置，返回。 mySolution: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int,int&gt; result; vector&lt;int&gt; return_back; int i = 0; for(i = 0;i &lt; nums.size();i++) { result.insert({nums[i],i}); } for(i = 0;i &lt; nums.size();i++) { int flag = 0; auto other_num = target - nums[i]; if(other_num != nums[i]) { auto it = result.find(other_num); if(it == result.end()) { continue; } else { return_back.push_back(i); return_back.push_back(it-&gt;second); flag = 1; } if(flag == 1) { break; } } else { if(count(nums.begin(),nums.end(),other_num) &gt; 1) { for(i = 0;i&lt;nums.size();i++) { if(nums[i] == other_num) { return_back.push_back(i); } } } else { continue; } } } return return_back; }}; 2. Add Two NumbersMedium You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 分析： 这题是一个链表的形式的加法题 整体就是一个加法进位，一个加法余位，两个位置分别保存。这题主要是长度的分类，我自己的思路就是对于较长的链表遍历完才结束遍历。对于短的链表就不停的加值为 0 的结点。 mySolution: 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int l1_num = 0,l2_num = 0,sum_result = 0,carry = 0; ListNode *head = l1; while(1) { sum_result = (l1-&gt;val + l2-&gt;val + carry) % 10; carry = (l1-&gt;val + l2-&gt;val + carry) / 10; l1-&gt;val = sum_result; if(l1-&gt;next == NULL &amp;&amp; l2-&gt;next != NULL) { l1-&gt;next = new ListNode(0); } else if(l1-&gt;next != NULL &amp;&amp; l2-&gt;next == NULL) { l2-&gt;next = new ListNode(0); } else if(l1-&gt;next == NULL &amp;&amp; l2-&gt;next == NULL) { if(carry) { l1-&gt;next = new ListNode(carry); } break; } l1 = l1-&gt;next; l2 = l2-&gt;next; } return head; }}; 3. Longest Substring Without Repeating CharactersMedium Given a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 分析： 这题是一个最长字符子串的问题。我个人想法使用一个字典来记录某字符出现次数。 我们用 i、j 指向头部，不断增加 j 的大小，不断增加字典中字符的次数，如果出现某一个字符串出现次数大于两次，就不断移动 i 直到没有重复字符串为止。最后 maxlen 不停更新为最大的值。 mySolution: 12345678910111213141516171819class Solution {public: int lengthOfLongestSubstring(string s) { unordered_map&lt;char,int&gt; sub_m; int i = 0,j = 0; int maxlen = 0; for(i = 0,j = 0;j&lt;s.size();j++) { ++sub_m[s[j]]; while(sub_m[s[j]] &gt; 1) { sub_m[s[i]]--; i++; } maxlen = max(maxlen,j-i+1); } return maxlen; }}; 4. Median of Two Sorted ArraysHard There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 分析： 这题我个人的思路是非常蠢的。。。先合并，在排序，在去取值 我在写这个文档的时候，也是不知道当时做这题是怎么想的。为什么用这种奇怪的方法，复杂度还高。 ！去看一下 find_k 算法 mySolution: 1234567891011121314151617181920212223242526272829class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int i = 0,j = 0; nums1.insert(nums1.end(), nums2.begin(), nums2.end()); multiset&lt;double&gt; num(nums1.cbegin(), nums1.cend()); multiset&lt;double&gt;::iterator set_it = num.begin(); double result = 0; if (nums1.size() % 2 == 0) { i = (nums1.size() / 2) -1; for (j = 0; j &lt; i; j++) { ++set_it; } result = (*set_it + *(++set_it)) / 2; } else { i = (nums1.size() - 1) / 2; for (j = 0; j &lt; i; j++) { ++set_it; } result = *set_it; } return result; } }; 5. Longest Palindromic SubstringMedium Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 分析： 这题我自己的做法，也是非常传统的想法实现，没有任何编程方面的技巧，就是硬想出来的 设置边界，需要找到相关的边界，来进行记录。首先跳过中间相同的字符，因为这个不影响是不是回文字符串 然后利用回文字符串的规则，进行比较，如果符合，就接着遍历。同时记录相关的位置信息 最后利用 substring 返回子字符串 mySolution: 1234567891011121314151617181920212223242526272829303132class Solution {public: string longestPalindrome(string s) { int low_bound = 0,high_bound = 0,max_len = 0,temp = 0,result_low = 0; if((s.empty()) || (s.size() == 1)) { return s; } else { for(int i = 0;(high_bound+1) &lt; s.size() &amp;&amp; max_len &lt;= s.size();) { low_bound = i; high_bound = i; while(s[high_bound] == s[high_bound + 1] &amp;&amp; (high_bound + 1) &lt; s.size()) { i = high_bound + 1; ++high_bound; } for(;low_bound &gt; 0 &amp;&amp; (high_bound+1) &lt; s.size() &amp;&amp; s[low_bound - 1] == s[high_bound + 1];--low_bound,++high_bound); temp = high_bound -low_bound + 1; if(temp &gt; max_len) { max_len = temp; result_low = low_bound; } i++; } return s.substr(result_low,max_len); } }}; 6. ZigZag ConversionMedium The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); Example 1: 12Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot; Example 2: 12345678Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I 分析： 感觉自己在前期做题的时候，确实没有想任何相关的编程技巧。都是自己想逻辑，然后自己把实现了。 这个自己的思路，就是申请一个 vector 来按一定的规则来存放传入的 s，因为我们看 Explanation 可以发现，这就是一种存储规则 存储完后，在用 for-each 循环再传入到一个result就可以了。 mySolution: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: string convert(string s, int numRows) { vector&lt;string&gt; result(numRows); string::iterator in = s.begin(); if (numRows &gt; 1) { int cycle_num = 2 * numRows - 2; for(int i = 0;i&lt;cycle_num;) { if(in != s.end()) { if(i &lt; numRows) { result[i] += *in; ++in; ++i; i = i%cycle_num; } else { result[cycle_num - i] += *in; ++in; ++i; i = i%cycle_num; } } else { break; } } string result_str; for(auto i : result) { result_str += i; } return result_str; } else { string result_str = s; return result_str; } }}; 7. Reverse IntegerEasy Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 分析： 感觉自己也是挺赖的，用了 to_string 转字符串，然后还用了 stoi 转会 int。可能第一遍刷的时候确实只是在解决问题，却不是最好的解决问题。 这题也就是简单的情况判断。大于 0 以及 小于 0 的情况，末尾几位为 0 的情况，最后如果溢出如何操作。 mySolution: 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: int reverse(int x) { int i = 0; int temp = x; string int_string = to_string(x); int result = 0; while (temp != 0) { if ((temp % 10) == 0) { ++i; temp = temp / 10; } else { break; } } if (x &gt;= 0) { std::reverse(int_string.begin(), int_string.end() - i); } else if (x &lt; 0) { std::reverse(int_string.begin() + 1, int_string.end() - i); } string result_string(int_string,0,int_string.size()-i); try { result = std::stoi(result_string); } catch(std::out_of_range err) { return 0; } return result; }}; 8. String to Integer (atoi)Medium Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned. Example 1: 12Input: &quot;42&quot;Output: 42 Example 2: 1234Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: 123Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: 1234Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: 1234Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 分析： 依然是自己硬想的逻辑，真的是太菜了。。。 这个题目也是不断的逻辑处理。先是删除掉前面的所有空格。分正负情况，将数字提取出来，然后判断有没有溢出，就完成了。 mySolution: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115class Solution {public: int myAtoi(string str) { int result = 0; string s; if(str.empty()) { return 0; } else { str.erase(0,str.find_first_not_of(&quot; &quot;)); if(str[0] &gt;= '0' &amp;&amp; str[0] &lt;= '9') { int i = 0; while(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9' &amp;&amp; i &lt;str.size()) { ++i; } s = str.substr(0,i); s.erase(0,s.find_first_not_of(&quot;0&quot;)); if(s.empty()) { return 0; } if(s.size() &gt;= 10) { if(s.size() &gt; 10) { return 2147483647; } else { if(s &gt; &quot;2147483647&quot;) { return 2147483647; } } } for(i = 0;i &lt; s.size();i++) { result = (result * 10 + (s[i] - '0')); } return result; } else if(str[0] == '-') { int i = 1; while(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9' &amp;&amp; i &lt; str.size()) { s += str[i]; ++i; } s.erase(0,s.find_first_not_of(&quot;0&quot;)); if(s.empty()) { return 0; } if(s.size() &gt;= 10) { if(s.size() &gt; 10) { return -2147483648; } else { if(s &gt;= &quot;2147483648&quot;) { return -2147483648; } } } for(i = 0;i &lt; s.size();i++) { result = result * 10 + (s[i] - '0') ; } return -result; } else if(str[0] == '+') { int i = 1; while(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9' &amp;&amp; i &lt; str.size()) { s += str[i]; ++i; } if(s.size() &gt;= 10) { if(s.size() &gt; 10) { return 2147483647; } else { if(s &gt;= &quot;2147483647&quot;) { return 2147483647; } } } for(i = 0;i &lt; s.size();i++) { result = result * 10 + (s[i] - '0') ; } return result; } else { return 0; } } }}; 9. Palindrome NumberEasy Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 分析： 虽然题目说不要使用 integer to a string，但是那样自己想的办法也就是取出每一位，然后重新构造一个数，看是否相等。 我这里直接也就直接转 string 然后 reverse 判断是否相等。 mySolution: 12345678910111213141516class Solution {public: bool isPalindrome(int x) { auto str_x = std::to_string(x); std::string str_y(str_x); reverse(str_y.begin(),str_y.end()); if(str_x == str_y) { return true; } else { return false; } }}; 10. Regular Expression MatchingHard Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. 12'.' Matches any single character.'*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;. Example 3: 12345Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4: 12345Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;. Example 5: 1234Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false 分析 ： 这题我个人觉得也是非常好，刚开始结合自己刚刚学习编译原理的原因，想弄个递归下降子程序，以及弹栈的思想。后来发现 * 不是很好处理，所以干脆直接递归处理，这也算是动态规划了吧。 首先将一些能直接返回的情况，判断完。然后就涉及到一些需要进一步判断的情况。 正常的字母匹配都不是关键的地方，这题的难度在于 .* 以及 [a-z]* 的 处理。 对于 [a-z]* 。因为 * 可以不匹配，所以我们还要判断不匹配的情况，是否能成功。这里直接使用递归，然后如果不匹配不成功的话，然后我们就需要接着判断到底匹配几个，这里又需要我们写循环，再循环里我们需要递归判断。成功的话，直接返回就好了。 对于 .* 。同样也是要判断表示是否匹配，以及匹配几个的问题。所以同样是递归来进行判断。 mySolution: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154class Solution {public: bool isMatch(string s, string p) { if(s.empty() &amp;&amp; p.empty()) { return true; } if(s.empty() &amp;&amp; (!p.empty())) { if(p.size() % 2 != 0) { return false; } else { for(int i = 1;i &lt; p.size();i += 2) { if(p[i] != '*') { return false; } } return true; } } if((!s.empty()) &amp;&amp; p.empty()) { return false; } int i = 0,j = 0; for(i = 0, j = 0;i &lt; s.size() &amp;&amp; j &lt; p.size();) { if(j != (p.size()-1)) { if(p[j] &gt;= 'a' &amp;&amp; p[j] &lt;= 'z') { if(p[j+1] &gt;= 'a' &amp;&amp; p[j+1] &lt;= 'z') { if(s[i] == p[j]) { ++i; ++j; } else { return false; } } else if(p[j+1] == '*') { while((j+3) &lt; p.size()) { if(p[j + 2] == p[j] &amp;&amp; p[j+3] == '*') { j += 2; } else { break; } } if(isMatch(s.substr(i),p.substr(j+2))) { return true; } else { while(s[i] == p[j]) { if(isMatch(s.substr(i),p.substr(j + 2))) { return true; } ++i; } j+=2; } } else if(p[j+1] == '.') { if(s[i] == p[j]) { ++i; ++j; } else { return false; } } } else if(p[j] == '.') { if(p[j+1] &gt;= 'a' &amp;&amp; p[j+1] &lt;= 'z') { ++i; ++j; } else if(p[j+1] == '*') { if(p.substr(j + 2).empty()) { return true; } else { while(i &lt;= s.size()) { if(isMatch(s.substr(i),p.substr(j+2))) { return true; } ++i; } return false; } } else if(p[j+1] == '.') { ++i; ++j; } } } else if(j == p.size() - 1) { if(i == s.size() -1) { if((p[j] == '.') || (s[i] == p[j])) { return true; } else { return false; } } else { return false; } } } if(isMatch(s.substr(i),p.substr(j))) { return true; } else { return false; } }}; 11. Container With Most WaterMedium Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: 12Input: [1,8,6,2,5,4,8,3,7]Output: 49 分析： 这题就是一个数学题吧，整体思路也比较清晰。 首先从头尾开始往中间进行遍历，因为宽度一直在减小，如果高度还减小，肯定是没有前种情况大的。所以我们一直遍历到，高度比前面大的情况。可以大大减少时间复杂度。 mySolution: 12345678910111213141516171819202122class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int i = 0,j = (height.size()-1); int min_height = 0; int water = 0; while(i &lt; j) { min_height = min(height[i],height[j]); water = max(water,min_height * (j-i)); while(height[i] &lt;= min_height &amp;&amp; i&lt;j) { ++i; } while(height[j] &lt;= min_height &amp;&amp; i&lt;j) { --j; } } return water; }}; 12. Integer to RomanMedium Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: 3Output: &quot;III&quot; Example 2: 12Input: 4Output: &quot;IV&quot; Example 3: 12Input: 9Output: &quot;IX&quot; Example 4: 123Input: 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3. Example 5: 123Input: 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 分析： 同样是正常的分类逻辑，完成逻辑即可 mySolution: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class Solution {public: string intToRoman(int num) { string result; for(;num &gt;= 1000;num = num - 1000,result += &quot;M&quot;); for(;num &gt;= 500;) { num = num - 500; if(num / 100 == 4) { result += &quot;CM&quot;; num = num - 400; } else { result += &quot;D&quot;; } } for(;num &gt;= 100;) { if(num / 100 == 4) { result += &quot;CD&quot;; num = num - 400; } else { num = num - 100; result += &quot;C&quot;; } } for(;num &gt;= 50;) { num = num - 50; if(num / 10 == 4) { result += &quot;XC&quot;; num = num - 40; } else { result += &quot;L&quot;; } } for(;num &gt;= 10;) { if(num / 10 == 4) { result += &quot;XL&quot;; num = num - 40; } else { result += &quot;X&quot;; num -= 10; } } for(;num &gt;= 1;) { if(num &gt;= 5) { if(num % 5 == 4) { result += &quot;IX&quot;; num -= 9; } else { num = num % 5; result += &quot;V&quot;; } } else { if(num == 4) { result += &quot;IV&quot;; break; } else { result += &quot;I&quot;; num--; } } } return result; }}; 13. Roman to IntegerEasy Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: &quot;III&quot;Output: 3 Example 2: 12Input: &quot;IV&quot;Output: 4 Example 3: 12Input: &quot;IX&quot;Output: 9 Example 4: 123Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3. Example 5: 123Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 分析： 用两个 vector 来存储相关的字符与数字的对应关系。 我们整体逻辑就是取位置的差距，然后去另一个 vector 找对应的值。当然要判断是不是特殊情况，整体逻辑也不是很难。 mySolution: 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int romanToInt(string s) { int num_result = 0; vector&lt;char&gt; roman_char{ 'I','V','X','L','C','D','M' }; vector&lt;int&gt; romen_int{ 1,5,10,50,100,500,1000 }; string::reverse_iterator in = s.rbegin(); vector&lt;char&gt;::iterator iter = find(roman_char.begin(), roman_char.end(),*in); auto dis = distance(roman_char.begin(), iter); int temp = dis; num_result += romen_int[dis]; ++in; for (unsigned int i = 1; i &lt; s.size(); i++) { iter = find(roman_char.begin(), roman_char.end(), *in); dis = distance(roman_char.begin(), iter); if (dis &gt;= temp) { num_result += romen_int[dis]; temp = dis; ++in; } else { num_result -= romen_int[dis]; temp = dis; ++in; } } return num_result; }}; 14. Longest Common PrefixEasy Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &quot;&quot;. Example 1: 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 123Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. 分析： 首先取所有字符串的最短长度 然后我们从 0 开始遍历，直到找到不是公共子串的长度。 mySolution: 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if(strs.empty()) { return &quot;&quot;; } else { int min_size = strs[0].size(); int flag = 0; string result; for(auto i : strs) { if(i.size() &lt; min_size) { min_size = i.size(); } } for(int j = 0;j &lt; min_size;++j) { string temp = strs[0].substr(0,(j+1)); flag = 0; for(auto str:strs) { if(str.substr(0,(j+1)) != temp) { ++flag; } } if(flag == 0) { result = temp; } } return result; } }}; 15. 3SumMedium Given an array nums of n integers, are there elements a, b, c in numssuch that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 分析： 这题我们需要将数组进行排序来减小时间复杂度 然后我们固定一个位置，将整个问题变成一个子问题。子问题就是在子数组里面找到对应的和为要求值的位置。然后不断增加 i 即可。 mySolution: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; num) { vector&lt;vector&lt;int&gt; &gt; res; std::sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) { int target = -num[i]; int front = i + 1; int back = num.size() - 1; while (front &lt; back) { int sum = num[front] + num[back]; if (sum &lt; target) front++; else if (sum &gt; target) back--; else { vector&lt;int&gt; triplet(3, 0); triplet[0] = num[i]; triplet[1] = num[front]; triplet[2] = num[back]; res.push_back(triplet); while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++; while (front &lt; back &amp;&amp; num[back] == triplet[2]) back--; } } while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) i++; } return res; }}; 16. 3Sum ClosestMedium Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 分析： 整体思路同样类似于上面那题 mySolution: 12345678910111213141516171819202122232425262728293031323334class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { int result = -2000000000; //返回保存结果 sort(nums.begin(),nums.end()); // 排序 for(int i = 0;i &lt; (nums.size()-2);i++) { int low_margin = i + 1; int high_margin = nums.size() - 1; for(low_margin = i + 1 ; low_margin != high_margin ;) //遍历过程 { int temp = (nums[i] + nums[low_margin] + nums[high_margin]); int distance = abs(result - target); if (temp == target) { return target; } else if (temp &gt; target) { if ((temp - target) &lt; distance) { result = temp; } --high_margin; } else if (temp &lt; target) { if ((target - temp) &lt; distance) { result = temp; } ++low_margin; } } } return result; }}; 17. Letter Combinations of a Phone NumberMedium Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: 12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 分析： 这题主要就是如何完成笛卡尔积，当然 python 很好完成 在 c++ 中笛卡尔积可以用递归，或者我这种方法。就是将大小提取出来，然后写循环。 mySolution 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { const vector&lt;string&gt; number_letter{&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;}; //声明一个包含规则的 vector vector&lt;string&gt; temp_number_letter; //存储需要使用到的 vector int total_size = 1; //存储笛卡尔积的 size 大小 vector&lt;string&gt; result; if(digits.empty()) { return result; } for(auto i:digits) { temp_number_letter.push_back(number_letter[ (i - '0') - 2]); } for(auto i:temp_number_letter) { total_size *= i.size(); } for( int i = 0 ; i &lt; total_size ; ++i ) { string loop_temp; int m = 0,n = i; for(auto r_iter : temp_number_letter) { //n = n % temp_number_letter[r_iter].size(); //loop_temp += temp_number_letter[r_iter][n]; m = n % r_iter.size(); n = n / r_iter.size(); loop_temp += r_iter[m]; } result.push_back((loop_temp)); } sort(result.begin(),result.end()); return result; }}; 18. 4SumMedium Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: 12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 分析： 我个人的想法就是将其转换成子问题 子问题就是 3sum，然后就可以完成了。 mySolution: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class Solution {private: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; num,int target) { // 提供给下面 fourSum 的接口 vector&lt;vector&lt;int&gt; &gt; result; // 返回的值 //vector&lt;int&gt; temp; // 作为中间值添加进结果 //std::sort(num.begin(), num.end()); //将传进来的值排序 for(unsigned int i = 0 ; i &lt; num.size() - 2 ; ++i) { unsigned int num_media = i + 1; // 中间的那个值 unsigned int num_right = num.size() - 1; // 右边的那个值 if(( num[i] + num[i+1] + num[i+2]) &gt; target) { break; } if(( num[i] + num[num_right - 1] + num[num_right]) &lt; target) { continue; } for( num_media = i + 1 ;num_media &lt; num_right; ) { int temp = num[i] + num[num_media] + num[num_right] ; if( temp &lt; target ) { ++num_media; } else if ( temp == target ) { result.push_back({num[i],num[num_media],num[num_right]}); ++num_media; --num_right; } else if( temp &gt; target ) { --num_right; } } } return result; }public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt; &gt; result; //返回值 if(nums.size() &lt; 4) { return result; } std::sort(nums.begin(), nums.end()); //排序 for( unsigned int i = 0; i &lt; (nums.size() - 3) ; ++i) { int threeSum_target = target - nums[i]; vector&lt;vector&lt;int&gt;&gt; threeSum_result; vector&lt;int&gt; threeSum_num(nums.begin() + i + 1, nums.end()); if(( nums[i] + nums[i+1] + nums[i+2] + nums[i+3]) &gt; target) { break; } if(( nums[i] + nums[nums.size() - 3] + nums[nums.size() - 2] + nums[nums.size() - 1]) &lt; target) { continue; } threeSum_result = threeSum(threeSum_num, threeSum_target); for(auto num:threeSum_result) { vector&lt;int&gt; temp; temp.push_back( nums[i] ); temp.insert(temp.end(),num.begin(),num.end()); if( find(result.begin(),result.end(),temp) != result.end() ) { continue; } else { result.push_back(temp); } } } return result; }}; 19. Remove Nth Node From End of ListMedium Given a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? 分析： 比较正常的链表题 mySolution: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* temp = head; int length = 1; if(head == NULL) { return NULL; } while(temp-&gt;next != NULL) { temp = temp-&gt;next; ++length; } if(length == 1 &amp;&amp; n == 1) { return NULL; } if(length == n) { head = head-&gt;next; return head; } length = length - 1 - n; temp = head; while(length != 0) { temp = temp-&gt;next; --length; } ListNode* del_node = temp-&gt;next; temp-&gt;next = temp-&gt;next-&gt;next; delete del_node; return head; }}; 20. Valid ParenthesesEasy Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: 12Input: &quot;()&quot;Output: true Example 2: 12Input: &quot;()[]{}&quot;Output: true Example 3: 12Input: &quot;(]&quot;Output: false Example 4: 12Input: &quot;([)]&quot;Output: false Example 5: 12Input: &quot;{[]}&quot;Output: true 分析： 如果学习过编译原理，很好理解，利用栈的语法判断 mySolution: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution {public: bool isValid(string s) { vector&lt;char&gt; stack; for(auto i : s) { if(i == '(' || i == '{' || i == '[') { stack.push_back(i); } else if(i == ')') { if(stack.empty()) { return false; } else if(stack.back() == '(') { stack.pop_back(); } else { return false; } } else if(i == '}') { if(stack.empty()) { return false; } else if(stack.back() == '{') { stack.pop_back(); } else { return false; } } else if(i == ']') { if(stack.empty()) { return false; } else if(stack.back() == '[') { stack.pop_back(); } else { return false; } } } if(stack.empty()) { return true; } else { return false; } }}; 21. Merge Two Sorted ListsEasy Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 分析： 常规的链表题 mySolution: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* l1_temp = l1; ListNode* l2_temp = l2; ListNode* head = new ListNode(0); ListNode* head_temp = head; while(l1_temp != NULL &amp;&amp; l2_temp != NULL) { if(l1_temp-&gt;val &gt; l2_temp-&gt;val) { head_temp-&gt;next = l2_temp; head_temp = head_temp-&gt;next; l2_temp = l2_temp-&gt;next; } else if(l1_temp-&gt;val == l2_temp-&gt;val) { head_temp-&gt;next = l1_temp; head_temp = head_temp-&gt;next; l1_temp = l1_temp-&gt;next; head_temp-&gt;next = l2_temp; head_temp = head_temp-&gt;next; l2_temp = l2_temp-&gt;next; } else if(l1_temp-&gt;val &lt; l2_temp-&gt;val) { head_temp-&gt;next = l1_temp; l1_temp = l1_temp-&gt;next; head_temp = head_temp-&gt;next; } } while(l1_temp != NULL) { head_temp-&gt;next = l1_temp; head_temp = head_temp-&gt;next; l1_temp = l1_temp-&gt;next; } while(l2_temp != NULL) { head_temp-&gt;next = l2_temp; head_temp = head_temp-&gt;next; l2_temp = l2_temp-&gt;next; } return head-&gt;next; }}; 22. Generate ParenthesesMedium Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 分析： 这题是一道非常好的训练递归思想的题目。 我们确立是递归类型的问题 我们寻找递归的规律，我们发现整体思路，就是要想是合法的就得一直确保插入过程当中剩下的左括号的数量不能多于右括号（想不明白，可以自己仔细思考一下），所以就写出了以下程序。 mySolution: 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;string&gt; result; if (n &lt;= 0) { return result; } recursive_func(n,n,&quot;&quot;,result); return result; } void recursive_func(int left_num , int right_num , string temp , vector&lt;string&gt; &amp;result) { if( left_num == 0 &amp;&amp; right_num == 0) { result.push_back(temp); return ; } if( left_num &gt; 0) { recursive_func( left_num-1 , right_num , temp+&quot;(&quot; ,result); } if( left_num &lt; right_num) { recursive_func( left_num , right_num-1 , temp+&quot;)&quot; ,result); } }}; 28. Implement strStr()Easy Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: 12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 Example 2: 12Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). 个人分析： 模拟strstr() 函数 我个人的想法可能就是寻找第一个字符匹配的位置，匹配后面。 !KMP算法 mySolution: 1234567891011121314151617181920212223242526272829class Solution {public: int strStr(string haystack, string needle) { int i = 0,j = 0; if(needle.empty()) { return 0; } if((needle.size() &gt; haystack.size()) || haystack.empty()) { return -1; } for(i = 0;i &lt; haystack.size();i++) { int temp = i ; int temp_j = j; while (haystack[temp] == needle[temp_j]) { if(temp_j == needle.size() - 1) { return i; } temp++; temp_j++; } } return -1; }};","link":"/2020/07/07/leetcode_recode/"},{"title":"PETS 论文架构分析","text":"Privacy Enhancing Technologies Symposium 不超过12页内容，不包括参考论文和附录内容（不限制页数） 整体架构 Abstract/Keywords（20-25行、4-6个） Introduction（1页半） Notation &amp; Background（1页） Related work（1页） 主要内容（3页） Experimental setup（1页半） Empirical results（2页半） Discussion and Future work（1页） Conclusion（15-20行） References（40-50个吧） 附录（A、B、C、D、E）","link":"/2022/02/07/pets%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"title":"LaTex技巧备忘","text":"LaTex技巧 文档类型（文章、报告、幻灯片）、宏包（\\usepackage{}）、模版 代码结构 123456789\\documentclass[]{}...... % 前导代码（preamble）\\begin{document}...... % 主体代码（body）\\end{document} \\part{}命令创建不同篇、使用\\chapter{}命令创建不同章、使用\\section{}命令创建一级节、使用\\subsection{}命令创建二级节、以及使用\\subsubsection{}命令创建三级节 \\uline可以增加单下划线，使用\\uuline可以增加双下划线，而使用\\uwave则可以增加波浪线，soul中的\\st命令生成删除线 反斜杠 (backslash) 符号使用\\textbackslash 如果我们想插入行内公式，可以直接在两个美元符号中间编辑需要的公式。如果想用美元符号插入行间公式，我们需要输入四个美元符号，与此同时，在四个美元符号中间编辑需要的公式。需要注意的是，这里生成的数学公式会自动居中对齐。 begin{equation}\\end{equation}，使用数学公式环境\\begin{equation} \\end{equation}， LaTeX编译时会自动将公式进行居中对齐。使用\\begin{equation*} \\end{equation*}就可以移除公式编号。 \\begin{align} \\end{align}，它主要用于数组型的数学表达式，align环境可以将公式进行自动对齐，它也能对每一条数学表达式分别进行公式编号。 \\begin{gather} \\end{gather}，它既可以将公式进行居中对齐，也能对每一条数学表达式分别进行公式编号 \\times，对应于符号×，\\cdot，对应于符号⋅，除法符号的命令为\\div ∩（\\cap）、∪（\\cup）、⊃（\\supset）、⊂（\\subset）、⊇（\\supseteq）、∈（\\in） 极限 $\\lim_{x\\to 2}x^{2}$，积分 \\int_{a}^{b}f(x),\\mathrm{d}x \\begin{array} \\end{array}环境来书写矩阵 LaTeX提供了多种表格环境用于制作各类表格，例如，tabular、tabular*、tabularx、tabulary、table和longtable等 12345678910111213141516\\begin{table} \\centering \\caption{Example of ABC} \\begin{tabular}{|c|c|c|c|} \\hline Column1 &amp; Column2 &amp; Column3 &amp; Column4\\\\ \\hline A1 &amp; A2 &amp; A3 &amp; A4\\\\ \\hline B1 &amp; B2 &amp; B3 &amp; B4\\\\ \\hline C1 &amp; C2 &amp; C3 &amp; C4\\\\ \\hline \\end{tabular} \\label{table1}% 索引标签\\end{table} LaTeX主要有两种管理参考文献的方法，第一种方法是在.tex文档中嵌入参考文献，参考文献格式需符合特定的文献引用格式；另一种方法则是使用 BibTeX进行文献管理，文件的拓展名为.bib。其中，使用外部文件BibTeX管理文献更加便捷高效。 bibtex：article：对应着期刊或杂志上发表的论文，必须添加的信息有author（作者）、title（标题）、journal（期刊）、year（年份）、volume（卷），可供选择添加的信息包括number（期）、pages（页码）、month（月份）、doi（数字对象识别码）等。 book：对应着书籍，必须添加的信息有author/editor（作者或主编）、title（书名）、publisher（出版社）、year（年份），可供选择添加的信息包括volume/number（卷/期）、series（系列）、address（出版地址）、edition（版号）、month（月份）、url（网址）等。 inbook：书籍中的一部分或者某一章节，必须添加的信息有author/editor、title（标题）、chapter/pages（章节/页码）、publisher（出版社）、year（年份），其他可供选择添加的信息与book一致。 inproceedings：对应着会议论文，必须添加的信息有author（作者）、title（论文标题）、booktitle（论文集标题）、year（年份），可供选择添加的信息包括editor（版号）、volume/number（卷或期）、series（系列）、pages（页码）、address（地址）、month（月份）、organization（组织方）、publisher（出版社）等。 conference：对应着会议论文，与inproceedings用法一致。 mastersthesis和proceedings：分别对应着硕士学位论文和博士学位论文，必须添加的信息有author（作者）、title（标题）、school（学校或研究机构）、year（年份）。 在LaTeX中插入Python代码可以使用verbatim环境，即在\\begin{verbatim} \\end{verbatim}之间插入代码 在LaTeX中，为了便于创建算法伪代码，现有很多相关的宏包，例如algorithm和algorithmic，在前导代码中申明使用这些宏包便可使用相应的算法伪代码环境。宏包algorithm提供的算法伪代码环境为\\begin{algorithm} \\end{algorithm}和\\begin{algorithmic} \\end{algorithmic}。","link":"/2022/02/09/latex_%E6%8A%80%E5%B7%A7/"},{"title":"科研绘图","text":"科研绘图 论文里的图可以分为模型图与数据展示图 配色一般是淡蓝、淡红、淡黄、淡绿 ，有时会用紫色、灰色补充（紫色多用于模块，灰色多用于小区域或者大面积打底） 模型图 可以使用 PPT 来画（我也觉得不错、相反visio不是很好用） 色调不宜太深，给人舒服的感觉 前后颜色需要一致 PPT文件可以直接导出为PDF，使用软件裁剪后即可插入到论文中，这样插入到论文里的是矢量图 数据展示图 latex 中的 tizk 包 matplotlib AxGlyph","link":"/2022/02/13/%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE/"},{"title":"Pytorch 环境配置日记","text":"Pytorch 环境配置日记 最近弄到实验室的两块 A5000 环境，想着把环境配好做实验，结果配置过程中发现怎么这么多坑（晕了！！） 正常配置 CPU 的版本是非常简单的，通过清华源快速又稳定 然而我是没想到 GPU 版本配置，真是废了我半条命 遇到的问题 服务器是共用的，每个人有自己的环境，所以我刚上的时候，发现 cudatoolkit 是配置好的，而且是 11.7 版本 于是我直接修改代码，开始跑实验，在我 torch.cuda 一切正常的情况下，告诉我缺少 lib 文件。于是我便寻找这个 lib 文件，确实找到了并添加环境变量，结果没用，依然报错！ 于是我想着那我自己重新配一个 cudatoolkit 环境，且我在 conda 过程中看到了那个 lib 。我开始重新配置，因为我上来就使用的是清华源，所以官网的 conda 命令无法使用，我想着应该无所谓，总有替换的命令 结果清华源一直报错，访问不了。这直接给我头整大了，我想着国内源也能访问不了，于是一通改配置文件，还是不行甚至卡。很久以后我把 我把 https -&gt; http 就正常了。。。 我想着这下 OK 了，下载过程中也确实 OK 了，结果我发现清华源的 cudatoolkit 版本没有 11.7，导致我 torch.cuda.is_avaiable() 一直 false，到底是不是版本问题待确定。于是我在 cuda 官网下了一个源文件，结果本地没有 sudo 权限，一时半会还给不了 最后我还是把 condarc 修改成原始配置，删除掉了清华源，看看最后结果如何 过了一晚，果然断了！外网是这样的，于是我想着就下老版本就可以吧，清华源不知道为什么没有跟进新版本，整个 torch 套装都落后好几个版本。老版本下载还算顺利 结果提醒一直没有 CUDNN 环境，于是我立马想到是不是和系统带的冲突了，因为我 CUDNN 下载的适配 CUDA11.3 而不是 CUDA11.7。于是我开始更换整个套装 torch、torchvision、CUDA、cuDNN ，直接从网站上下载然后 SCP 进去。结果这次提醒我，CUDNN 申请不到资源，我真是傻了。于是我找了同门，让他在那边实验，结果他环境也有问题，后来弄好了和我说他也申请不到。 原来是同门在上面跑巨大模型，又过了一天，终于成功跑起了我的代码，真是坎坷 总结 国内源不是无脑上的，需要具体问题解决，上网问题真是难呀","link":"/2022/02/15/pytorch%E4%B8%8B%E8%BD%BD%E6%97%A5%E8%AE%B0/"},{"title":"Pate_alibi 代码阅读记录","text":"Pate_alibi 代码阅读记录 文件夹目录如下├── CONTRIBUTING.md├── LICENSE├── README.md├── aggregate_votes.py├── cifar10│ └── cifar10├── lib│ ├── init.py│ ├── pycache│ ├── dataset│ ├── fixmatch.py│ ├── models│ └── pate├── memorization_attack│ ├── attack.py│ ├── confs│ └── confs_10x100├── pate│ ├── teacher_0.ckp│ └── teacher_0.ckp_ema├── requirements.txt├── train_cifar_alibi.py├── train_student.py└── train_teacher.py 整个代码贯穿着 logging 模块，很有利于调试，是很不错的习惯 使用 simple_parsing 处理命令行参数（对于后续实验调整参数非常方便） 整体代码架构也很清晰，将 setting 独立出来","link":"/2023/02/20/Pate_alibi%20%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"英语 留学","slug":"英语-留学","link":"/tags/%E8%8B%B1%E8%AF%AD-%E7%95%99%E5%AD%A6/"},{"name":"基础知识","slug":"基础知识","link":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"阅读","slug":"阅读","link":"/tags/%E9%98%85%E8%AF%BB/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","link":"/tags/%E4%BB%A3%E7%A0%81/"}],"categories":[],"pages":[{"title":"","text":"关于我还不知道怎么介绍自己 Lookup 网络安全方向, CTF player, 前华为实习生，现苦逼研究生 也没有什么理想，希望自己每天开开心心得 Email: starlookup@gmail.com","link":"/about/index.html"}]}